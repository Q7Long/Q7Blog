---
title: V3_TS_CMS重点
date: 2023-02-17 20:07:53
permalink: /pages/50edbe/
categories:
  - 技术
  - 日常积累
tags:
  - 
author: 
  name: Q7Long
  link: https://github.com/Q7Long
---
#### 1.项目重点一：

> 当通过路由守卫，检查如果有token直接跳转到首页，没有跳转到登录页的时候，需要判断去的不是登录页，然后判断是否有token，如果没有就跳到登录页，如果有则直接跳过登录页直接去首页

```ts
// 导航守卫，检查如果有token直接跳转到首页，没有跳转到登录页
router.beforeEach((to) => {
  if (to.path !== '/login') {
    // 如果不是登录页的话，需要判断是否有token
    const token = localCache.getCache('token')
    if (!token) {
      // 如果没有 token 跳转到登录页
      return '/login'
    }
  }
})
```

> 但是直接跳到首页，vuex中的数据是通过，登录的时候提交修改数据的操作提交 Mutation 来存储到 vuex 中的，直接跳过登录就没有办法提交 Mutation，那么该如何将数据数据在直接跳到首页时候存储到 vuex 中

`src\store\index.ts`   在 store 中单独封装一个 `loadLocalLogin action`

```ts
import { createStore } from 'vuex'
import type { IRootState } from './types'
// 注册 login 模块
import login from './login/login'

// createStore 要求传入一个对象
const store = createStore<IRootState>({
  // 对象里面是函数
  state() {
    return {
      name: 'Q7Long',
      age: 23
    }
  },
  mutations: {},
  actions: {},
  modules: {
    login
  }
})

//如果用户通过token直接进入首页，那么store中是没有信息的，如何做呢？
// 用户每次进入都会调用函数初始化 store 中的数据
export function setupStore() {
  // 在 store 中单独封装一个 loadLocalLogin action
  store.dispatch('/login/loadLocalLogin')
}
// 导出 store
export default store

```

`src\store\login\login.ts`   封装初始化函数

```ts
import type { Module } from 'vuex'
import type { ILoginState } from './types'
import type { IRootState } from '../types'
import type { IAccount } from '@/service/login/type'
import router from '@/router' // 获取router对象
// 请求信息接口配置
import {
  accountLoginRequest,
  requestUserInfoById,
  requestUserMenusByRoleId
} from '@/service/login/login'
import localCache from '@/utils/cache'
const loginModule: Module<ILoginState, IRootState> = {
  // 模块化要添加命名空间
  namespaced: true, // 不添加这个会导致 [vuex] unknown action type: login/accountLoginAction 无法获取 actions
  state() {
    return {
      token: '', // 存放 token
      userInfo: {}, // 存放用户信息
      userMenus: [], // 用于存放用户菜单数量
      permissions: []
    }
  },
  getters: {},
  // 修改数据的方式
  mutations: {
    // 将token保存在 vuex 中
    changeToken(state, token: string) {
      // console.log(token)
      // 将传入的 token 保存到 vuex 中
      state.token = token
    },
    // 保存用户信息
    changeUserInfo(state, userInfo: any) {
      state.userInfo = userInfo
    },
    // 保存用户请求菜单信息
    changeUserMenus(state, userMenus: any) {
      state.userMenus = userMenus
    }
  },
  // 点击登录触发 action
  actions: {
    // 账号登录
    async accountLoginAction({ commit }, payload: IAccount) {
      // console.log('执行accountLoginAction', payload)
      // 实现登录逻辑 accountLoginRequest() 函数返回的是 promise  同步方式写异步代码
      const loginResult = await accountLoginRequest(payload)
      const { id, token } = loginResult.data
      // console.log(loginResult.data.id, loginResult.data.token)
      // 提交修改数据的操作提交 Mutation
      commit('changeToken', token)
      // 将token进行本地缓存，需要token的地方直接从本地 localStorage 获取
      localCache.setCache('token', token)

      //2. 登录成功请求用户信息
      const userInfoResult: any = await requestUserInfoById(id)
      // 请求用户信息，需要携带token，在拦截器中进行配置 service/index.ts
      // console.log(userInfoResult)  // 打印用户信息
      const userInfo = userInfoResult.data
      commit('changeUserInfo', userInfo)
      // 用户信息进行缓存，方便下次免登录直接读取用户信息
      localCache.setCache('userInfo', userInfo)

      // 3.请求用户菜单
      const userMenusResult = await requestUserMenusByRoleId(userInfo.role.id)
      const userMenus = userMenusResult.data
      // console.log(userMenus)
      commit('changeUserMenus', userMenus)

      // 4. 跳到首页
      router.push('/main')
    },
    // 初始化 store 的 action，在本地存储中将数据取出来重新提交commit存入vuex中
    loadLocalLogin({ commit }) {
      const token = localCache.getCache('token')
      if (token) {
        commit('changeToken', token)
      }
      const userInfo = localCache.getCache('userInfo')
      if (token) {
        commit('changeUserInfo', userInfo)
      }
      const userMenus = localCache.getCache('userMenus')
      if (token) {
        commit('changeUserMenus', userMenus)
      }
    },

    // 手机号登录
    phoneLoginAction({ commit }, payload: any) {
      console.log('执行phoneLoginAction11', payload)
    }
  }
}

export default loginModule

```

`src\main.ts` 在 `main.ts `中调用 store 中单独封装的 action

#### 2.项目重点二： 当登录之后获取到token，需要在获取用户信息和获取用户信息可以看到的列表的时候时候该怎么办呢？

首先封装一个 `src\utils\cache.ts`  本地缓存数据的工具函数

```ts
// 缓存 类有更强的封装性，封装一些方法
class LocalCache {
  // 本地缓存数据
  setCache(key: string, value: any) {
    window.localStorage.setItem(key, JSON.stringify(value))
  }
  getCache(key: string) {
    const value = window.localStorage.getItem(key)
    if (value) {
      return JSON.parse(value)
    }
  }
  deleteCache(key: string) {
    window.localStorage.removeItem(key)
  }
  // 清除所有缓存
  clearCache() {
    window.localStorage.clear()
  }
}

export default new LocalCache()
```

`src\store\login\login.ts` 然后在登陆的时候获取到token，调用封装好的工具函数，将 token 存在`localStorage` 中，可以对 axios 进行二次封装，然后在里面设置 interceptors 拦截器，在拦截器中从 `localStorage` 中取出来 token，在全局拦截器中将 token  放进请求头中，这样每次都不用在获取信息的时候重新提交 token 了

在拦截中还可以封装全局 Loading 效果，在加载数据的时候就可以显示全局loading，在数据请求结束就将全局 loading 通过 close()方法 移除，通过 `this.instance.interceptors.request.use` 使用封装好的拦截器

#### 3. 动态路由

##### 后端

![image-20230208165359716](http://www.zhangqilong.cn/img/qlBlog_images/%E6%8A%80%E6%9C%AF/%E6%97%A5%E5%B8%B8%E7%A7%AF%E7%B4%AF/v3_ts_cms%E9%87%8D%E7%82%B9/image-20230208165359716.png)

**一对多，两张表，多的表加外键**

**多对多，三张表，关系表加外键**



登录成功之后返回一个 `token` ，还有用户信息 `userInfo` ，在返回的用户信息数据中是包含了 `role` 包含的角色，角色的 `id` 和 `name` 都是可以展示的，还有一个就是 `userMenus` (用户的权限)，`userMenus` 就是通过多对多的关系表查询出来的结果，也就是用户的权限

##### 前端

`userMenus` 就是用户拥有的权限，前端最终要的就是 `userMenus`

**动态路由的第二种方案**

![image-20230208170959306](http://www.zhangqilong.cn/img/qlBlog_images/%E6%8A%80%E6%9C%AF/%E6%97%A5%E5%B8%B8%E7%A7%AF%E7%B4%AF/v3_ts_cms%E9%87%8D%E7%82%B9/image-20230208170959306.png)

**动态路由的第三种方案(采用)**

**控制登录用户的权限**

思路：服务器返回一个菜单 Menu，希望动态注册路由，菜单并不是写死的，将所有的路由都写入，而是动态注册路由

**映射关系：** `menu` 菜单里面有 `url`，`url` 对应的是路由里面的 `path`，而一个 `path` 对应的是一个 `component(page页面)`

`component(page页面)` 需要提前先创建好，根据映射关系（映射关系其实就是一个对象 {path: , component: } ）

根据 `url` 去找到 `{path:,component:}` 对象并且把这个对象进行一个加载就可以

由于有很多的组件，所以可以采用 `coderwhy` 工具，来生成对应的组件和映射关系



![image-20230208171506089](http://www.zhangqilong.cn/img/qlBlog_images/%E6%8A%80%E6%9C%AF/%E6%97%A5%E5%B8%B8%E7%A7%AF%E7%B4%AF/v3_ts_cms%E9%87%8D%E7%82%B9/image-20230208171506089.png)



根据菜单动态的注册路由，而不是一次性写完（一次性注册完存在隐患，就是用户可以通过url直接访问本来访问不到的内容）



```ts
npm install coderwhy

// coderwhy add3page 组件的名称 文件位置 存放在哪个目录

coderwhy add3page user -d src/views/main/system/user
coderwhy add3page role -d src/views/main/system/role
coderwhy add3page department -d src/views/main/system/department
coderwhy add3page menu  -d src/views/main/system/menu


coderwhy add3page category  -d src/views/main/product/category
coderwhy add3page goods -d src/views/main/product/goods

// 随便聊聊
coderwhy add3page chat  -d src/views/main/story/chat
coderwhy add3page list  -d src/views/main/story/list


coderwhy add3page overview  -d src/views/main/analysis/overview
coderwhy add3page dashboard  -d src/views/main/analysis/dashboard
```

自动生成目录，并且自动配置路由映射关系

![image-20230208173148954](http://www.zhangqilong.cn/img/qlBlog_images/%E6%8A%80%E6%9C%AF/%E6%97%A5%E5%B8%B8%E7%A7%AF%E7%B4%AF/v3_ts_cms%E9%87%8D%E7%82%B9/image-20230208173148954.png)

下面从服务器获取的数据，如果数据中的 url 与路由映射关系 url 相匹配的话，那么说明用户是有这个菜单的权限的，就添加到 routes 里面

![image-20230208173843464](http://www.zhangqilong.cn/img/qlBlog_images/%E6%8A%80%E6%9C%AF/%E6%97%A5%E5%B8%B8%E7%A7%AF%E7%B4%AF/v3_ts_cms%E9%87%8D%E7%82%B9/image-20230208173843464.png)



1. 路由映射关系

![image-20230208174228126](http://www.zhangqilong.cn/img/qlBlog_images/%E6%8A%80%E6%9C%AF/%E6%97%A5%E5%B8%B8%E7%A7%AF%E7%B4%AF/v3_ts_cms%E9%87%8D%E7%82%B9/image-20230208174228126.png)

2. 拿到菜单，让路由里面的 url 匹配路由的映射关系，有映射关系就将其放进数组 `routes` 中，没有就不放进去，匹配完成之后  `routes` 中存放的就是当前用户所拥有的权限，该去注册的路由 **routes是动态的而不是写死的状态**
3. 在 `login.ts` 中在获取菜单的时候，将过滤出来的 routes 将注册进行注册出来

`src\utils\map-menus.ts`

```ts
// export function mapMenusToRoutes(userMenus: any[]): RouteRecordRaw[] {
//   const routes: RouteRecordRaw[] = []
//   const routeFiles = require.context('../router/main', true, '/.ts/')
//   routeFiles.keys().forEach((key) => {
//     const route = require('../router/main' + key.split('.')[1])
//     allRoutes.push(route.default)
//   })
//   console.log(allRoutes) // 与一直导入效果一样，但是 require 问题无法解决
//   // 1.先去加载默认所有的routes
//   const allRoutes: RouteRecordRaw[] = []
//   return routes
// }

import type { RouteRecordRaw } from 'vue-router'
import obj from '../router/main/analysis/dashboard/dashboard'
import obj1 from '../router/main/analysis/overview/overview'
import obj2 from '../router/main/product/category/category'
import obj3 from '../router/main/product/goods/goods'
import obj4 from '../router/main/story/chat/chat'
import obj5 from '../router/main/story/list/list'
import obj6 from '../router/main/system/department/department'
import obj7 from '../router/main/system/menu/menu'
import obj8 from '../router/main/system/role/role'
import obj9 from '../router/main/system/user/user'
export function mapMenusToRoutes(userMenus: any[]): RouteRecordRaw[] {
  // 先去加载默认所有的 routes
  const routes: RouteRecordRaw[] = []
  const allRoutes: RouteRecordRaw[] = []
  allRoutes.push(obj)
  allRoutes.push(obj1)
  allRoutes.push(obj2)
  allRoutes.push(obj3)
  allRoutes.push(obj4)
  allRoutes.push(obj5)
  allRoutes.push(obj6)
  allRoutes.push(obj7)
  allRoutes.push(obj8)
  allRoutes.push(obj9)
  // console.log(allRoutes)  // 所有路由对象 routes 存放的数组

  // 2. 根据菜单获取所有需要添加的 routes 路由

  // userMenus:
  // type ===1 -> children -> type ===1  type不等于一说明是可以展开的菜单，进行递归直到等于2
  // type ===2 -> url -> route

  // 封装递归函数获取 Route 最后将获取到的 route 放进 routes 数组中
  const _recurseGetRoute = (menus: any[]) => {
    for (const menu of menus) {
      if (menu.type === 2) {
        const route = allRoutes.find((route) => {
          // 找到 url 中对用的 route
          return route.path === menu.url
        })
        // 如果找到对应的 route 就将其 push 到数组中
        if (route) routes.push(route)
      } else {
        // type ===1 需要递归调用，直到type===2
        _recurseGetRoute(menu.children)
      }
    }
  }
  _recurseGetRoute(userMenus)
  return routes
}
```

`src\store\login\login.ts`

```ts
import type { Module } from 'vuex'
import type { ILoginState } from './types'
import type { IRootState } from '../types'
import type { IAccount } from '@/service/login/type'
import { mapMenusToRoutes } from '@/utils/map-menus'
import router from '@/router' // 获取router对象
// 请求信息接口配置
import {
  accountLoginRequest,
  requestUserInfoById,
  requestUserMenusByRoleId
} from '@/service/login/login'
import localCache from '@/utils/cache'
const loginModule: Module<ILoginState, IRootState> = {
  // 模块化要添加命名空间
  namespaced: true, // 不添加这个会导致 [vuex] unknown action type: login/accountLoginAction 无法获取 actions
  state() {
    return {
      token: '', // 存放 token
      userInfo: {}, // 存放用户信息
      userMenus: [], // 用于存放用户菜单数量
      permissions: []
    }
  },
  getters: {},
  // 修改数据的方式
  mutations: {
    // 将token保存在 vuex 中
    changeToken(state, token: string) {
      // console.log(token)
      // 将传入的 token 保存到 vuex 中
      state.token = token
    },
    // 保存用户信息
    changeUserInfo(state, userInfo: any) {
      state.userInfo = userInfo
    },
    // 保存用户请求菜单信息
    changeUserMenus(state, userMenus: any) {
      state.userMenus = userMenus

      // 在 utils 工具中封装方法，直接调用
      // 获取到 userMenus 之后将其映射到 routes 里面 userMenus=>routes
      const routes = mapMenusToRoutes(userMenus)
      // console.log(routes) // 获取到该用户说用能看到的路由映射对象(即路由)

      // 将 routes 添加到 router.main.children
      // 动态添加路由                                               // 重点
      routes.forEach((route) => {
        // 找到对应的一级路由添加 过滤出来的route 注册所有的路由
        router.addRoute('main', route)
      })
    }
  },
  // 点击登录触发 action
  actions: {
    // 账号登录
    async accountLoginAction({ commit }, payload: IAccount) {
      // console.log('执行accountLoginAction', payload)
      // 实现登录逻辑 accountLoginRequest() 函数返回的是 promise  同步方式写异步代码
      const loginResult = await accountLoginRequest(payload)
      const { id, token } = loginResult.data
      // console.log(loginResult.data.id, loginResult.data.token)
      // 提交修改数据的操作提交 Mutation
      commit('changeToken', token)
      // 将token进行本地缓存，需要token的地方直接从本地 localStorage 获取
      localCache.setCache('token', token)

      //2. 登录成功请求用户信息
      const userInfoResult: any = await requestUserInfoById(id)
      // 请求用户信息，需要携带token，在拦截器中进行配置 service/index.ts
      // console.log(userInfoResult)  // 打印用户信息
      const userInfo = userInfoResult.data
      commit('changeUserInfo', userInfo)
      // 用户信息进行缓存，方便下次免登录直接读取用户信息
      localCache.setCache('userInfo', userInfo)

      // 3.请求用户菜单
      const userMenusResult = await requestUserMenusByRoleId(userInfo.role.id)
      const userMenus = userMenusResult.data
      console.log(userMenus)
      commit('changeUserMenus', userMenus)
      localCache.setCache('userMenus', userMenus)

      // 4. 跳到首页
      router.push('/main')
    },
    // 初始化 store 的 action，在本地存储中将数据取出来重新提交commit存入vuex中
    loadLocalLogin({ commit }) {
      const token = localCache.getCache('token')
      if (token) {
        commit('changeToken', token)
      }
      const userInfo = localCache.getCache('userInfo')
      if (userInfo) {
        commit('changeUserInfo', userInfo)
      }
      const userMenus = localCache.getCache('userMenus')
      if (userMenus) {
        commit('changeUserMenus', userMenus)
      }
    },

    // 手机号登录
    phoneLoginAction({ commit }, payload: any) {
      console.log('执行phoneLoginAction11', payload)
    }
  }
}

export default loginModule
```

`src\components\nav-menu\src\nav-menu.vue`

```ts
<template>
  <div class="nav-menu">
    <div class="logo">
      <img class="img" src="~@/assets/img/logo.svg" alt="logo" />
      <span v-if="!collapse" class="title">Vue3+TS</span>
    </div>
    <!-- collapse 折叠属性 -->
    <el-menu
      default-active="defaultValue"
      :unique-opened="false"
      text-color="#b7bdc3"
      :collapse="collapse"
      background-color="#0c2135"
      class="el-menu-vertical"
      active-text-color="#0a60bd"
    >
      <template v-for="item in userMenus" :key="item.id">
        <!-- 二级菜单 type=1进行展示-->
        <template v-if="item.type === 1">
          <!-- 二级菜单可以展开的标题  设置 :index 唯一标识来确定选中状态-->
          <el-sub-menu :index="item.id + ''">
            <!-- submenu的标题 -->
            <template #title>
              <i v-if="item.icon" :class="item.icon"></i>
              <span>{{ item.name }}</span>
            </template>
            <!-- submenu的内容 遍历里面的item -->
            <template v-for="subitem in item.children" :key="subitem.id">
              <el-menu-item :index="subitem.id + ''" @click="handleMenuItemClick(subitem)">
                <i v-if="subitem.icon" :class="subitem.icon">{{ subitem.id }}</i>
                <span>{{ subitem.name }}</span>
              </el-menu-item>
            </template>
          </el-sub-menu>
        </template>
        <!-- 一级菜单 type=2进行展示-->
        <template v-else-if="item.type === 2">
          <!-- id是数组类型，但是要求的 index 是字符串类型 -->
          <el-menu-item :index="item.id + ''">
            <i v-if="item.icon" :class="item.icon">{{ item.id }}</i>
          </el-menu-item>
        </template>
      </template>
    </el-menu>
  </div>
</template>

<script lang="ts">
import { defineComponent, computed, ref } from 'vue'
import { useStore } from '@/store/index' // 重新封装的 useStore
import { useRouter } from 'vue-router'
export default defineComponent({
  // 接收是否需要折叠的状态
  props: {
    collapse: {
      type: Boolean,
      default: false
    }
  },
  setup() {
    // store
    const store = useStore()
    const userMenus = computed(() => store.state.login.userMenus)
    const router = useRouter()
    // 定义菜单点击事件
    const handleMenuItemClick = (item: any) => {
      // console.log(item) //{id: 40, url: '/main/analysis/dashboard', name: '商品统计', sort: 107, type: 2, …}
      router.push({
        // 路径就会发生改变                                        // 重点
        path: item.url ?? '/not-found'
      })
    }
    return {
      userMenus,
      handleMenuItemClick
    }
  }
})
</script>

<style scoped lang="less">
</style>
```

### User 组件

#### 3. 高阶组件

`src\base-ui\form\types\index.ts`

```ts
import { placeholderSign } from 'element-plus/es/components/table-v2/src/private'

type IFormType = 'input' | 'password' | 'select' | 'datepicker'
export interface IFormItem {
  type: IFormType
  label: string
  rules?: any[]
  placeholder?: any
  // 针对 select
  options?: any[]
  // 针对特殊的属性
  otherOptions?: any
  itemStyle?: []
}

export interface IForm {
  formItems: IFormItem[]
  labelWidth?: string
  colLayout: any
  itemLayout: any
}
```

`src\views\main\system\user\user.vue`

```vue
<template>
  <div class="user">
    <div class="search">
      <!-- <ql-form
        :form-items="formItems"
        :labelWidth="labelWidth"
        :itemStyle="itemStyle"
        :colLayout="colLayout"
      /> -->
      <ql-form v-bind="searchFormConfig" />
    </div>
    <div class="content">内容</div>
  </div>
</template>

<script lang="ts">
import { defineComponent } from 'vue'
import QlForm from '@/base-ui/form'
// 导入封装好的配置文件
import { searchFormConfig } from './config/search.config'
export default defineComponent({
  components: {
    QlForm
  },
  name: 'user',
  setup() {
    // 外界决定输入框宽度
    // 外界传入的样式
    // 默认情况下一行显示三个

    return { searchFormConfig }
  }
})
</script>

<style scoped></style>
```

`src\base-ui\form\src\form.vue`

```vue
<template>
  <div class="ql-form">
    <el-form :label-width="labelWidth">
      <el-row>
        <template v-for="item in formItems" key="item.label">
          <el-col v-bind="collLayout">
            <!-- 直接使用 props 传入的 itemStyle -->
            <el-form-item :label="item.label" :rules="item.rules" :style="itemStyle">
              <template v-if="item.type === 'input' || item.type === 'password'">
                <el-input :placeholder="item.placeholder" />
              </template>
              <template v-else-if="item.type === 'select'">
                <el-select :placeholder="item.placeholder" style="width: 100%">
                  <el-option
                    v-for="option in item.options"
                    :key="option.value"
                    :value="option.value"
                    >{{ option.title }}</el-option
                  >
                </el-select>
              </template>
              <template v-else-if="item.type === 'datepicker'">
                <!-- 直接绑定其他属性 -->
                <el-date-picker style="width: 100%" v-bind="item.otherOptions" />
              </template>
            </el-form-item>
          </el-col>
        </template>
      </el-row>
    </el-form>
  </div>
</template>

<script lang="ts">
import { defineComponent } from 'vue'
import type { PropType } from 'vue'
import type { IFormItem } from '../types'
export default defineComponent({
  props: {
    formItems: {
      // [{label,value}] 确定数组里面的东西
      type: Array as PropType<IFormItem[]>,
      // 默认值注意点：对象和数组的高级类型需要写成箭头函数
      default: () => [] // 默认值空数组
    },
    labelWidth: {
      type: String,
      default: '100px'
    },
    itemStyle: {
      type: Object,
      // 默认的 padding
      default: () => ({ padding: '10px 40px' })
    },
    // 响应式
    collLayout: {
      type: Object,
      default: () => ({
        xl: 8, //>1920 的屏幕占4个
        lg: 8,
        md: 12,
        sm: 24,
        xs: 24
      })
    }
  },
  setup() {
    return {}
  }
})
</script>

<style scoped lang="less">
.ql-form {
  padding-top: 22px;
}
</style>
```

`src\views\main\system\user\config\search.config.ts`

后续开发高阶组件的时候，只需要修改配置文件即可
```ts
import type { IForm } from '@/base-ui/form'
export const searchFormConfig: IForm = {
  labelWidth: '120px',
  itemLayout: {
    padding: '10px 40px'
  },
  colLayout: {
    span: 8
  },
  formItems: [
    {
      type: 'input',
      label: 'id',
      placeholder: '请输入id',
      rules: [],
      itemStyle: []
    },
    {
      type: 'password',
      label: '密码',
      placeholder: '请输入密码'
    },
    {
      type: 'select',
      label: '喜欢',
      placeholder: '请输入喜欢的内容',
      options: [
        { title: '篮球', value: 'basketball' },
        { title: '足球', value: 'football' }
      ]
    },
    {
      type: 'datepicker',
      label: '创建时间',
      otherOptions: {
        startPlaceholder: '开始时间',
        endPlaceholder: '结束时间',
        type: 'daterange'
      }
    }
  ]
}
```

那么当我们获取数据的时候，比如获取表单中数据，那么我们就需要收集好表单中的数据并且在 use.vue 中获取到数据那么该如何做呢？

###### 方案一：违规，在子组件中接收 props 并且修改数据

```vue
<template>
  <div class="user">
    <div class="search">
      <!-- <ql-form
        :form-items="formItems"
        :labelWidth="labelWidth"
        :itemStyle="itemStyle"
        :colLayout="colLayout"
      /> -->
      <!--收集表单中数据3 -->
      <ql-form v-bind="searchFormConfig" :formData="formData" />
    </div>
    <div class="content">内容</div>
  </div>
</template>

<script lang="ts">
// 收集表单中数据1
import { defineComponent, reactive } from 'vue'
import QlForm from '@/base-ui/form'
// 导入封装好的配置文件
import { searchFormConfig } from './config/search.config'
export default defineComponent({
  components: {
    QlForm
  },
  name: 'user',
  setup() {
    // 收集表单中数据2
    const formData = reactive({
      id: '',
      name: '',
      password: '',
      sport: '',
      createTime: ''
    })
    return {
      searchFormConfig,
      formData
    }
  }
})
</script>

<style scoped></style>
```

在组件中接收数据，但是需要在 types 中规定类型添加一个 `field`

`src\base-ui\form\src\form.vue`

```vue
<template>
  <div class="ql-form">
    <el-form :label-width="labelWidth">
      <el-row>
        <template v-for="item in formItems" key="item.label">
          <el-col v-bind="collLayout">
            <!-- 直接使用 props 传入的 itemStyle -->
            <el-form-item :label="item.label" :rules="item.rules" :style="itemStyle">
              <template v-if="item.type === 'input' || item.type === 'password'">
                <el-input
                  :placeholder="item.placeholder"
                  v-bind="item.otherOptions"
                  :show-password="item.type === 'password'"
                  v-model="formData[`${item.field}`]"
                />
              </template>
              <template v-else-if="item.type === 'select'">
                <el-select
                  :placeholder="item.placeholder"
                  style="width: 100%"
                  v-bind="item.otherOptions"
                  v-model="formData[`${item.field}`]"
                >
                  <el-option
                    v-for="option in item.options"
                    :key="option.value"
                    :value="option.value"
                    >{{ option.title }}</el-option
                  >
                </el-select>
              </template>
              <template v-else-if="item.type === 'datepicker'">
                <!-- 直接绑定其他属性 -->
                <el-date-picker
                  v-model="formData[`${item.field}`]"
                  style="width: 100%"
                  v-bind="item.otherOptions"
                />
              </template>
            </el-form-item>
          </el-col>
        </template>
      </el-row>
    </el-form>
  </div>
</template>

<script lang="ts">
import { defineComponent } from 'vue'
import type { PropType } from 'vue'
import type { IFormItem } from '../types'
export default defineComponent({
  props: {
    formData: {
      type: Object,
      require: true
    ··················
  },
  setup() {
    return {}
  }
})
</script>

<style scoped lang="less">
.ql-form {
  padding-top: 22px;
}
</style>
```

`src\base-ui\form\types\index.ts`

```ts
import { placeholderSign } from 'element-plus/es/components/table-v2/src/private'

type IFormType = 'input' | 'password' | 'select' | 'datepicker'
export interface IFormItem {
  field: string
  type: IFormType
  label: string
  rules?: any[]
  placeholder?: any
  // 针对 select
  options?: any[]
  // 针对特殊的属性
  otherOptions?: any
  itemStyle?: []
}

export interface IForm {
  formItems: IFormItem[]
  labelWidth?: string
  colLayout: any
  itemLayout: any
}
```

![image-20230210202344219](http://www.zhangqilong.cn/img/qlBlog_images/%E6%8A%80%E6%9C%AF/%E6%97%A5%E5%B8%B8%E7%A7%AF%E7%B4%AF/v3_ts_cms%E9%87%8D%E7%82%B9/image-20230210202344219.png)

###### 方案二： 使用 reactive 定义数据

父组件通过 v-model 传给子组件数据，子组件通过 modelValue 接收数据，然后使用计算属性对 modelValue 进行赋值，操作赋值出来对 formdata

`src\views\main\system\user\user.vue`

```ts
<template>
  <div class="user">
    <div class="search">
      <!-- <ql-form v-bind="searchFormConfig" :formData="formData" /> -->
      <!-- 方案二：v-model -->
      <ql-form v-bind="searchFormConfig" v-model="formData" />
    </div>
    <div class="content">内容</div>
  </div>
</template>

<script lang="ts">
import { defineComponent, reactive } from 'vue'
import QlForm from '@/base-ui/form'
// 导入封装好的配置文件
import { searchFormConfig } from './config/search.config'
export default defineComponent({
  components: {
    QlForm
  },
  name: 'user',
  setup() {
    const formData = reactive({
      id: '',
      password: '',
      sport: '',
      createTime: ''
    })
    return {
      searchFormConfig,
      formData
    }
  }
})
</script>

<style scoped></style>
```

`src\base-ui\form\src\form.vue`

```vue
<template>
  <div class="ql-form">
    <el-form :label-width="labelWidth">
      <el-row>
        <template v-for="item in formItems" key="item.label">
          <el-col v-bind="collLayout">
            <!-- 直接使用 props 传入的 itemStyle -->
            <el-form-item :label="item.label" :rules="item.rules" :style="itemStyle">
              <template v-if="item.type === 'input' || item.type === 'password'">
                <el-input
                  :placeholder="item.placeholder"
                  v-bind="item.otherOptions"
                  :show-password="item.type === 'password'"
                  v-model="formData[`${item.field}`]"
                />
              </template>
              <template v-else-if="item.type === 'select'">
                <el-select
                  :placeholder="item.placeholder"
                  style="width: 100%"
                  v-bind="item.otherOptions"
                  v-model="formData[`${item.field}`]"
                >
                  <el-option
                    v-for="option in item.options"
                    :key="option.value"
                    :value="option.value"
                    >{{ option.title }}</el-option
                  >
                </el-select>
              </template>
              <template v-else-if="item.type === 'datepicker'">
                <!-- 直接绑定其他属性 -->
                <el-date-picker
                  v-model="formData[`${item.field}`]"
                  style="width: 100%"
                  v-bind="item.otherOptions"
                />
              </template>
            </el-form-item>
          </el-col>
        </template>
      </el-row>
    </el-form>
  </div>
</template>

<script lang="ts">
import { computed, defineComponent } from 'vue'
import type { PropType } from 'vue'
import type { IFormItem } from '../types'
export default defineComponent({
  props: {
    //1. 父组件使用子组件时候 v-model 传入数据
    modelValue: {
      type: Object,
      require: true
    },
    // formData: {
    //   type: Object,
    //   require: true
    // },
    formItems: {
      // [{label,value}] 确定数组里面的东西
      type: Array as PropType<IFormItem[]>,
      // 默认值注意点：对象和数组的高级类型需要写成箭头函数
      default: () => [] // 默认值空数组
    },
    labelWidth: {
      type: String,
      default: '100px'
    },
    itemStyle: {
      type: Object,
      // 默认的 padding
      default: () => ({ padding: '10px 40px' })
    },
    // 响应式
    collLayout: {
      type: Object,
      default: () => ({
        xl: 8, //>1920 的屏幕占4个
        lg: 8,
        md: 12,
        sm: 24,
        xs: 24
      })
    }
  },
  // emit 发送一个事件
  emits: ['update:modelValue'],
  setup(props, { emit }) {
    // 思路一：
    const formData = computed({
      //2. 这样做没有直接使用别人传来的 modelValue
      get: () => props.modelValue,
      set: (newValue) => {
        emit('update:modelValue', newValue)
      }
    })
    return {
      formData
    }
  }
})
</script>

<style scoped lang="less">
.ql-form {
  padding-top: 22px;
}
</style>
```

```vue
emits: ['update:modelValue'],
  setup(props, { emit }) {
    // 思路一：
    const formData = computed({
      // 这样做没有直接使用别人传来的 modelValue
      get: () => props.modelValue,
      set: (newValue) => {
        console.log('_______')
        emit('update:modelValue', newValue)
      }
    })
```

但是这样的结果就是修改数据的时候，set 方法是没有被调用的

![image-20230210211902203](http://www.zhangqilong.cn/img/qlBlog_images/%E6%8A%80%E6%9C%AF/%E6%97%A5%E5%B8%B8%E7%A7%AF%E7%B4%AF/v3_ts_cms%E9%87%8D%E7%82%B9/image-20230210211902203.png)

这样其实就相当于是直接绑定的  v-model="formData" 就相当于是 :modelValue = "formData" 依然是修改的formData 中的数据

```vue
<template>
  <div class="user">
    <div class="search">
      <!-- <ql-form v-bind="searchFormConfig" :formData="formData" /> -->
      <!-- 方案二：v-model 相当于是 :modelValue = "formData" -->
      <ql-form v-bind="searchFormConfig" v-model="formData" /> 
    </div>
    <div class="content">内容</div>
  </div>
</template>
```

###### 方案三  不使用 reactive 而使用 ref

`src\views\main\system\user\user.vue`

```vue
<template>
  <div class="user">
    <div class="search">
      <!-- <ql-form v-bind="searchFormConfig" :formData="formData" /> -->
      <!-- 方案二：v-model -->
      <ql-form v-bind="searchFormConfig" v-model="formData" />
    </div>
    <div class="content">内容</div>
  </div>
</template>

<script lang="ts">
import { defineComponent, ref } from 'vue'
import QlForm from '@/base-ui/form'
// 导入封装好的配置文件
import { searchFormConfig } from './config/search.config'
export default defineComponent({
  components: {
    QlForm
  },
  name: 'user',
  setup() {
    // 外界决定输入框宽度
    // 外界传入的样式
    // 默认情况下一行显示三个
    const formData = ref({
      id: '',
      password: '',
      sport: '',
      createTime: ''
    })
    return {
      searchFormConfig,
      formData
    }
  }
})
</script>

<style scoped></style>
```

`src\base-ui\form\src\form.vue`

```vue
<template>
  <div class="ql-form">
    <el-form :label-width="labelWidth">
      <el-row>
        <template v-for="item in formItems" key="item.label">
          <el-col v-bind="collLayout">
            <!-- 直接使用 props 传入的 itemStyle -->
            <el-form-item :label="item.label" :rules="item.rules" :style="itemStyle">
              <template v-if="item.type === 'input' || item.type === 'password'">
                <el-input
                  :placeholder="item.placeholder"
                  v-bind="item.otherOptions"
                  :show-password="item.type === 'password'"
                  v-model="formData[`${item.field}`]"
                />
              </template>
              <template v-else-if="item.type === 'select'">
                <el-select
                  :placeholder="item.placeholder"
                  style="width: 100%"
                  v-bind="item.otherOptions"
                  v-model="formData[`${item.field}`]"
                >
                  <el-option
                    v-for="option in item.options"
                    :key="option.value"
                    :value="option.value"
                    >{{ option.title }}</el-option
                  >
                </el-select>
              </template>
              <template v-else-if="item.type === 'datepicker'">
                <!-- 直接绑定其他属性 -->
                <el-date-picker
                  v-model="formData[`${item.field}`]"
                  style="width: 100%"
                  v-bind="item.otherOptions"
                />
              </template>
            </el-form-item>
          </el-col>
        </template>
      </el-row>
    </el-form>
  </div>
</template>

<script lang="ts">
import { computed, defineComponent, ref, watch } from 'vue'
import type { PropType } from 'vue'
import type { IFormItem } from '../types'
export default defineComponent({
  props: {
    // 父组件使用子组件时候 v-model 传入数据
    modelValue: {
      type: Object,
      require: true
    },
    // formData: {
    //   type: Object,
    //   require: true
    // },
    formItems: {
      // [{label,value}] 确定数组里面的东西
      type: Array as PropType<IFormItem[]>,
      // 默认值注意点：对象和数组的高级类型需要写成箭头函数
      default: () => [] // 默认值空数组
    },
    labelWidth: {
      type: String,
      default: '100px'
    },
    itemStyle: {
      type: Object,
      // 默认的 padding
      default: () => ({ padding: '10px 40px' })
    },
    // 响应式
    collLayout: {
      type: Object,
      default: () => ({
        xl: 8, //>1920 的屏幕占4个
        lg: 8,
        md: 12,
        sm: 24,
        xs: 24
      })
    }
  },
  // emit 发送一个事件
  emits: ['update:modelValue'],
  setup(props, { emit }) {
      
    // 思路一： 摒弃
    // const formData = computed({
    // 这样做没有直接使用别人传来的 modelValue
    // get: () => props.modelValue,
    // set: (newValue) => {
    //   console.log('_______')
    //   emit('update:modelValue', newValue)
    // }

    // const formData = ref({props.modelValue}) 这样依旧使用的是父组件中的内容
    // 思路三：将对象拷贝一份放入新的对象中，当数据发生改变的时候通过 emit 发送出去
    // 这种方式实现的双向绑定，而不是通过引用去修改
    const formData = ref({ ...props.modelValue })
    // 监听 formData,deep = true 当对象中某一个属性发生改变也会监听到发出事件
    watch(formData, (newValue) => emit('update:modelValue', newValue), {
      deep: true
    })
    return {
      formData
    }
  }
})
</script>

<style scoped lang="less">
.ql-form {
  padding-top: 22px;
}
</style>
```



###### 当数据中有多个数据绑定的时候就需要按照上面的方案三，因为需要从上面对象中要取出来一个属性进行绑定，

emit 发送一个事件之后用 v-model="formData" 接收

这时候 user 和 form 的数据都会被修改

##### 但是如果只有一个数据的话可以直接使用 v-model 绑定即可

```vue
<template>
  <div class="user">
    <div class="search">
      <ql-form v-bind="searchFormConfig" v-model="password" />
    </div>
    <div class="content">内容</div>
  </div>
</template>

<script lang="ts">
import { defineComponent, ref } from 'vue'
import QlForm from '@/base-ui/form'
// 导入封装好的配置文件
import { searchFormConfig } from './config/search.config'
export default defineComponent({
  components: {
    QlForm
  },
  name: 'user',
  setup() {
    const password = ref('')
    return {
      searchFormConfig,
      formData
    }
  }
})
</script>

<style scoped></style>
```

`src\base-ui\form\src\form.vue`

```vue
<template v-if="item.type === 'input' || item.type === 'password'">
    <el-input
       v-model="modelValue"
 	/>
</template>

<script lang="ts">
export default defineComponent({
  props: {
    modelValue: {
      type: string,
      require: true
    },
    return {
    }
  }
})
</script>

<style scoped lang="less">
</style>
```

对组件进行封装之后，那么可以从最外层通用的  ql-form ql-form 可以根据传入的内容（类型，可选select）来决定显示几个 input 框

并且对格式进行设置，比如长度 IForm 是在这里面配置 IFormItem 里面即配置了 IForm  有配置了是什么类型的 框框，对格式规定完之后，就可以对里面的内容进行绑定，这个时候在 `src\components\page-search\src\page-search.vue`  里面设置数据，将通过父组件传入的 porps:`searchFormConfig` 就可以直接放进组件中进行数据绑定，最后只需要在 user 里面将数据传入即可

数据部分

`src\views\main\system\user\config\search.config.ts`

```ts
import type { IForm } from '@/base-ui/form'
export const searchFormConfig: IForm = {
  labelWidth: '120px',
  itemLayout: {
    padding: '10px 40px'
  },
  colLayout: {
    span: 8
  },
  // 如何与from中数据一一对应
  formItems: [
    {
      // 1
      field: 'id',
      type: 'input',
      label: 'id',
      placeholder: '请输入id',
      rules: [],
      itemStyle: []
    },
    {
      field: 'password',
      type: 'password',
      label: '密码',
      placeholder: '请输入密码'
    },
    {
      field: 'sport',
      type: 'select',
      label: '喜欢',
      placeholder: '请输入喜欢的内容',
      options: [
        { title: '篮球', value: 'basketball' },
        { title: '足球', value: 'football' }
      ]
    },
    {
      field: 'createTime',
      type: 'datepicker',
      label: '创建时间',
      otherOptions: {
        startPlaceholder: '开始时间',
        endPlaceholder: '结束时间',
        type: 'daterange'
      }
    }
  ]
}
```

组件部分

`src\views\main\system\user\config\search.config.ts`

```vue
<template>
  <div class="user">
    <page-search :searchFormConfig="searchFormConfig"></page-search>
    <div class="content"></div>
  </div>
</template>

<script lang="ts">
import { defineComponent } from 'vue'
// 导入封装好的配置文件
import { searchFormConfig } from './config/search.config'
import PageSearch from '@/components/page-search'
export default defineComponent({
  components: { PageSearch },
  name: 'user',
  setup() {
    return {
      searchFormConfig
    }
  }
})
</script>

<style scoped>
.header {
  color: red;
}
.handle-btns {
  text-align: right;
  padding: 0 50px 20px 0;
}
</style>
```

###### 请求数据封装流程

```ts
1. 在 user.vue 中调用 disPath 一个 action 就会到 store 中 system 的 actions 中的 getPageListAction 函数中，在 service 中的 system 中的 system.ts 中发送网络请求，将数据请求并且返回到 store 中，完成之后，将数据进行解构并且存放到 store 中的 userList 和 userCount
```

##### 动态插槽

当我们有一个需求，就是一行数据的某一列数据需要展示的是 `button` 按钮样式

![image-20230211165051107](http://www.zhangqilong.cn/img/qlBlog_images/%E6%8A%80%E6%9C%AF/%E6%97%A5%E5%B8%B8%E7%A7%AF%E7%B4%AF/v3_ts_cms%E9%87%8D%E7%82%B9/image-20230211165051107.png)

那么我们就可以使用动态插槽

> 首先将 table 组件抽离成一个通用的组件，放在 page-ui 中

`src\base-ui\table\src\table.vue`

```vue
<template>
  <div class="ql-table">
    <el-table :data="listData" border style="width: 100%">
      <template v-for="propItem in propList" :key="propItem.prop">
        <!-- <el-table-column prop="item.name" label="用户名" min-width="180" /> -->
        <el-table-column v-bind="propItem" align="center">
          <!-- 插槽  scope.row 就是当前行的数据 -->
          <template #default="scope">
            <!-- scope.row[propItem.prop] 就想当与是 scope.row[name、realname]  -->
            <!-- <el-button>{{ scope.row[propItem.prop] }}</el-button> --->
            <!-- 但是默认情况下，我们有的数据是不需要成为按钮的，有的数据则需要是按钮样式，怎么做呢？插槽 -->
            <!--插槽名字不能写死，因为只是想改某几列，固定找到某一列的插槽，在 user 中 propList 中添加 slotName -->
            <slot :name="propItem.slotName" :row="scope.row">
              {{ scope.row[propItem.prop] }}
            </slot>
          </template>
        </el-table-column>
      </template>
    </el-table>
  </div>
</template>

<script lang="ts">
import { defineComponent } from 'vue'

export default defineComponent({
  props: {
    listData: {
      type: Array,
      require: true
    },
    propList: {
      type: Array,
      require: true
    }
  },
  setup() {
    return {}
  }
})
</script>

<style scoped></style>
```

> 在 base-ui 的 table 文件夹下创建一个 index ，用于导出组件

`src\base-ui\table\index.ts`

```ts
import QlTable from './src/table.vue'

export default QlTable
```

> 使用组件的时候直接在 user 文件夹下，导入，并且将网络请求下来的数据进行传入
>
> 在使用之前首先需要对数据进行预处理，将请求下来的数据放进 `propList` 中进行格式化，直接放入 table 中就可以按照 ` :propList="propList"` 就行导入，`v-for="propItem in propList"` 使用组件接收到的数据，而不用一个个的写 `<el-table-column prop="item.name" label="用户名" min-width="180" />`  快速开发

`src\views\main\system\user\user.vue`

```vue
<template>
  <div class="user">
    <page-search :searchFormConfig="searchFormConfig"></page-search>
    <div class="content">
      <ql-table :listData="userList" :propList="propList">
        <!-- 指定将 status 改为插槽，只改 status 对应的列数据 -->
        <template #status="scope">
          <el-button>{{ scope.row.enable ? '启用' : '禁用' }}</el-button>
        </template>
        <template #createAt="scope">
          <strong>{{ scope.row.createAt }}</strong>
        </template>
      </ql-table>
    </div>
  </div>
</template>

<script lang="ts">
import { computed, defineComponent } from 'vue'
// 导入封装好的配置文件
import { searchFormConfig } from './config/search.config'
import PageSearch from '@/components/page-search'
// 使用包装类型后的 useStore 会有类型提示
import { useStore } from '@/store'
import QlTable from '@/base-ui/table'

export default defineComponent({
  components: { PageSearch, QlTable },
  name: 'user',
  setup() {
    const store = useStore()
    // 调用 system 中的 action 这样可以从外面规定传入的参数
    store.dispatch('system/getPageListAction', {
      pageUrl: '/users/list', // 请求路径
      queryInfo: {
        offset: 0,
        size: 10
      }
    })
    // 从 store 中获取数据
    const userList = computed(() => store.state.system.userList)
    const userCount = computed(() => store.state.system.userCount)

    // 针对于 userList 添加配置文件
    const propList = [
      { prop: 'name', label: '用户名', minWidth: '100' },
      { prop: 'realname', label: '真实姓名', minWidth: '100' },
      { prop: 'cellphone', label: '手机号码', minWidth: '100' },
      { prop: 'enable', label: '状态', minWidth: '100', slotName: 'status' },
      { prop: 'createAt', label: '创建时间', minWidth: '100', slotName: 'createAt' },
      { prop: 'updateAt', label: '更新时间', minWidth: '100', slotName: 'updateAt' }
    ]
    return {
      searchFormConfig,
      userList,
      userCount,
      propList
    }
  }
})
</script>

<style scoped>
.content {
  padding: 20px;
  border-top: 20px solid #f5f5f5;
}
</style>
```

##### 在 main.ts 配置 globalRegister 调用 globalRegister 之后，执行globalRegister里面配置的全部全局函数

```ts
import { createApp } from 'vue'
import router from './router'
import store from './store'
import 'normalize.css'
import './assets/css/index.less'
import App from './App.vue'
import 'element-plus/dist/index.css'
import { setupStore } from './store'
import 'default-passive-events'

import { globalRegister } from './global'
const app = createApp(App)

// 调用全局函数
app.use(globalRegister)
app.use(store)
// 注意顺序
// 因为注册路由 app.use(router) -> install函数（获取当前浏览器的path）
// 在这一刻拿到路径之后，就会去匹配 router.routes 这使用由于还没有注册路由所以会出现路径是对的，但是结果是错的
// 需要注意的是这个需要放在 use(router) 之前
setupStore() // 每次进入都有初始化 store 中的数据
app.use(router)

app.mount('#app')
```

`src\global\index.ts`

```ts
import type { App } from 'vue'
import registerElementIcon from './register-element-icon'
import registerProperties from './register-properties'

export function globalRegister(app: App): void {
  app.use(registerElementIcon)
  app.use(registerProperties)
}
```

`src\global\register-properties.ts`

```ts
import type { App } from 'vue'
import { formatUtcString } from '@/utils/date-format'

export default function registerProperties(app: App) {
  app.config.globalProperties.$filters = {
    formatTime(value: string) {
      // 格式化shi
      return formatUtcString(value)
    }
  }
}
```

`src\utils\date-format.ts`  格式化时间的工具函数  将 `utc` 时间进行格式化

```ts
import dayjs from 'dayjs'
import utc from 'dayjs/plugin/utc'

// dayjs 库默认不支持 utc 格式的时间，所以需要先将 utc 导入到 dayjs 库中
dayjs.extend(utc)

const DATA_TIME_FORMAT = 'YYY-MM-DD HH:mm:ss' // 格式化默认值

export function formatUtcString(utcString: string, format: string = DATA_TIME_FORMAT) {
  // 使用 dayjs 库 npm install dayjs
  return dayjs.utc(utcString).format(format)
}
```

##### 封装组件之列表序号和选中

> 用户可以根据传入的值来决定是否显示序号选项

`src\views\main\system\user\user.vue`

```vue
<template>
  <div class="user">
    <page-search :searchFormConfig="searchFormConfig"></page-search>
    <div class="content">
      <ql-table
        :listData="userList"
        :propList="propList"
        :showIndexColum="showIndexColum"
        :showSelectColumn="showSelectColumn"
      >
        <!-- 指定将 status 改为插槽，只改 status 对应的列数据 -->
        <template #status="scope">
          <el-button size="small" :type="scope.row.enable ? 'success' : 'danger'" plain>{{
            scope.row.enable ? '启用' : '禁用'
          }}</el-button>
        </template>
        <template #createAt="scope">
          {{ $filters.formatTime(scope.row.createAt) }}
        </template>
        <template #updateAt="scope">
          {{ $filters.formatTime(scope.row.updateAt) }}
        </template>
      </ql-table>
    </div>
  </div>
</template>

<script lang="ts">
import { computed, defineComponent } from 'vue'
// 导入封装好的配置文件
import { searchFormConfig } from './config/search.config'
import PageSearch from '@/components/page-search'
// 使用包装类型后的 useStore 会有类型提示
import { useStore } from '@/store'
import QlTable from '@/base-ui/table'

export default defineComponent({
  components: { PageSearch, QlTable },
  name: 'user',
  setup() {
    const store = useStore()
    // 调用 system 中的 action 这样可以从外面规定传入的参数
    store.dispatch('system/getPageListAction', {
      pageUrl: '/users/list', // 请求路径
      queryInfo: {
        offset: 0,
        size: 10
      }
    })
    // 从 store 中获取数据
    const userList = computed(() => store.state.system.userList)
    const userCount = computed(() => store.state.system.userCount)

    // 针对于 userList 添加配置文件
    const propList = [
      { prop: 'name', label: '用户名', minWidth: '100' },
      { prop: 'realname', label: '真实姓名', minWidth: '100' },
      { prop: 'cellphone', label: '手机号码', minWidth: '100' },
      { prop: 'enable', label: '状态', minWidth: '100', slotName: 'status' },
      { prop: 'createAt', label: '创建时间', minWidth: '100', slotName: 'createAt' },
      { prop: 'updateAt', label: '更新时间', minWidth: '100', slotName: 'updateAt' }
    ]

    // 是否显示序号，默认显示，再次使用可以根据传入的 true 和 false 来决定是否显示
    const showIndexColum = true
    // 选中按钮功能
    const showSelectColumn = true

    return {
      searchFormConfig,
      userList,
      userCount,
      propList,
      showIndexColum,
      showSelectColumn
    }
  }
})
</script>

<style scoped>
.content {
  padding: 20px;
  border-top: 20px solid #f5f5f5;
}
</style>
```

`src\base-ui\table\src\table.vue`

```vue
<template>
  <div class="ql-table">
    <el-table :data="listData" border style="width: 100%" @selection-change="handleSelectionChange">
      <el-table-column type="selection" v-if="showSelectColumn" width="80px" align="center">
      </el-table-column>
      <el-table-column
        v-if="showIndexColum"
        type="index"
        label="序号"
        align="center"
        width="80px"
      ></el-table-column>
      <template v-for="propItem in propList" :key="propItem.prop">
        <!-- <el-table-column prop="item.name" label="用户名" min-width="180" /> -->
        <el-table-column v-bind="propItem" align="center">
          <!-- 插槽  scope.row 就是当前行的数据 -->
          <template #default="scope">
            <!-- scope.row[propItem.prop] 就想当与是 scope.row[name、realname]  -->
            <!-- <el-button>{{ scope.row[propItem.prop] }}</el-button> --->
            <!-- 但是默认情况下，我们有的数据是不需要成为按钮的，有的数据则需要是按钮样式，怎么做呢？插槽 -->
            <!--插槽名字不能写死，因为只是想改某几列，固定找到某一列的插槽，在 user 中 propList 中添加 slotName -->
            <slot :name="propItem.slotName" :row="scope.row">
              {{ scope.row[propItem.prop] }}
            </slot>
          </template>
        </el-table-column>
      </template>
    </el-table>
  </div>
</template>

<script lang="ts">
import { defineComponent } from 'vue'

export default defineComponent({
  props: {
    listData: {
      type: Array,
      require: true
    },
    propList: {
      type: Array,
      require: true
    },
    //是否显示序号列，默认不显示
    showIndexColum: {
      type: Boolean,
      default: false
    },
    // 是否显示选中按钮
    showSelectColumn: {
      type: Boolean,
      default: false
    }
  },
  emits: ['selectionChange'],
  setup(props, { emit }) {
    // 当选中按钮生效的时候，触发的事件
    const handleSelectionChange = (value: any) => {
      // console.log(value)  // 获取到的数据
      // 当选中的数据发送到上一层，对数据进行处理
      emit('selectionChange', value)
    }
    return {
      handleSelectionChange
    }
  }
})
</script>

<style scoped></style>
```

##### 显示按钮(按钮后期需要权限控制所以需要添加 slotName)  *按钮写在 user.vue 中，意味着可以做权限控制，有的时候显示，有的时候不显示* 

`src\views\main\system\user\user.vue`

```vue
<template>
  <div class="user">
    <page-search :searchFormConfig="searchFormConfig"></page-search>
    <div class="content">
      <ql-table
        :listData="userList"
        :propList="propList"
        :showIndexColum="showIndexColum"
        :showSelectColumn="showSelectColumn"
      >
        <!-- 指定将 status 改为插槽，只改 status 对应的列数据 -->
        <template #status="scope">
         <el-button size="small" :type="scope.row.enable ? 'success' : 'danger'" plain>            {{ scope.row.enable ? '启用' : '禁用' }}
    	 </el-button>
        </template>
        <template #createAt="scope">
          {{ $filters.formatTime(scope.row.createAt) }}
        </template>
        <template #updateAt="scope">
          {{ $filters.formatTime(scope.row.updateAt) }}
        </template>
        <!-- 按钮写在 user.vue 中，意味着可以做权限控制，有的时候显示，有的时候不显示 -->
        <template #handler>
          <div class="handle-btns">
            <el-button icon="edit" size="small" type="text">编辑</el-button>
            <el-button icon="delete" size="small" type="danger">删除</el-button>
          </div>
        </template>
      </ql-table>
    </div>
  </div>
</template>

<script lang="ts">
import { computed, defineComponent } from 'vue'
// 导入封装好的配置文件
import { searchFormConfig } from './config/search.config'
import PageSearch from '@/components/page-search'
// 使用包装类型后的 useStore 会有类型提示
import { useStore } from '@/store'
import QlTable from '@/base-ui/table'

export default defineComponent({
  components: { PageSearch, QlTable },
  name: 'user',
  setup() {
    const store = useStore()
    // 调用 system 中的 action 这样可以从外面规定传入的参数
    store.dispatch('system/getPageListAction', {
      pageUrl: '/users/list', // 请求路径
      queryInfo: {
        offset: 0,
        size: 10
      }
    })
    // 从 store 中获取数据
    const userList = computed(() => store.state.system.userList)
    const userCount = computed(() => store.state.system.userCount)

    // 针对于 userList 添加配置文件
    const propList = [
      { prop: 'name', label: '用户名', minWidth: '100' },
      { prop: 'realname', label: '真实姓名', minWidth: '100' },
      { prop: 'cellphone', label: '手机号码', minWidth: '100' },
      { prop: 'enable', label: '状态', minWidth: '100', slotName: 'status' },
      { prop: 'createAt', label: '创建时间', minWidth: '100', slotName: 'createAt' },
      { prop: 'updateAt', label: '更新时间', minWidth: '100', slotName: 'updateAt' },
      { label: '操作', minWidth: '120', slotName: 'handler' }
    ]

    // 是否显示序号，默认显示，再次使用可以根据传入的 true 和 false 来决定是否显示
    const showIndexColum = true
    // 选中按钮功能
    const showSelectColumn = true

    return {
      searchFormConfig,
      userList,
      userCount,
      propList,
      showIndexColum,
      showSelectColumn
    }
  }
})
</script>

<style scoped>
.content {
  padding: 20px;
  border-top: 20px solid #f5f5f5;
}
</style
```

##### 将  user 页面中内容进行抽取成配置文件

> 网络请求数据还是在 user.vue 中进行写，但是固定的死信息可以抽离出一个配置文件，然后在组件上使用 v-bind 直接进行绑定

`src\views\main\system\user\user.vue`

```ts
<template>
  <div class="user">
    <page-search :searchFormConfig="searchFormConfig"></page-search>
    <div class="content">
      <ql-table :listData="userList" v-bind="contentTableConfig">
        <!-- 指定将 status 改为插槽，只改 status 对应的列数据 -->
        <template #status="scope">
          <el-button size="small" :type="scope.row.enable ? 'success' : 'danger'" plain>{{
            scope.row.enable ? '启用' : '禁用'
          }}</el-button>
        </template>
        <template #createAt="scope">
          {{ $filters.formatTime(scope.row.createAt) }}
        </template>
        <template #updateAt="scope">
          {{ $filters.formatTime(scope.row.updateAt) }}
        </template>
        <!-- 按钮写在 user.vue 中，意味着可以做权限控制，有的时候显示，有的时候不显示 -->
        <template #handler>
          <div class="handle-btns">
            <el-button icon="edit" size="small" type="text">编辑</el-button>
            <el-button icon="delete" size="small" type="danger">删除</el-button>
          </div>
        </template>

        <!-- 决定header 和 footer 长什么样子 -->
        <template #header></template>
        <template #footer></template>
        <!-- 按钮插槽 -->
        <template #headerHandler>
          <el-button type="primary">新建用户</el-button>
          <el-button icon="refresh">刷新</el-button>
        </template>
      </ql-table>
    </div>
  </div>
</template>

<script lang="ts">
import { computed, defineComponent } from 'vue'
// 导入封装好的配置文件
import { searchFormConfig } from './config/search.config'
import PageSearch from '@/components/page-search'
// 使用包装类型后的 useStore 会有类型提示
import { useStore } from '@/store'
import QlTable from '@/base-ui/table'

// 对配置文件进行导入
import { contentTableConfig } from './config/content.config'

export default defineComponent({
  components: { PageSearch, QlTable },
  name: 'user',
  setup() {
    const store = useStore()
    // 调用 system 中的 action 这样可以从外面规定传入的参数
    store.dispatch('system/getPageListAction', {
      pageUrl: '/users/list', // 请求路径
      queryInfo: {
        offset: 0,
        size: 10
      }
    })
    // 从 store 中获取数据
    const userList = computed(() => store.state.system.userList)
    const userCount = computed(() => store.state.system.userCount)

    return {
      searchFormConfig,
      userList,
      userCount,
      contentTableConfig
    }
  }
})
</script>

<style scoped>
.content {
  padding: 20px;
  border-top: 20px solid #f5f5f5;
}
</style>
```

> 配置文件

`src\views\main\system\user\config\content.config.ts`

```ts
// 对页面中固定死的东西进行抽离

// 用户管理内容配置
export const contentTableConfig = {
  // 针对于 userList 添加配置文件
  propList: [
    { prop: 'name', label: '用户名', minWidth: '100' },
    { prop: 'realname', label: '真实姓名', minWidth: '100' },
    { prop: 'cellphone', label: '手机号码', minWidth: '100' },
    { prop: 'enable', label: '状态', minWidth: '100', slotName: 'status' },
    { prop: 'createAt', label: '创建时间', minWidth: '100', slotName: 'createAt' },
    { prop: 'updateAt', label: '更新时间', minWidth: '100', slotName: 'updateAt' },
    { label: '操作', minWidth: '120', slotName: 'handler' }
  ],

  // 是否显示序号，默认显示，再次使用可以根据传入的 true 和 false 来决定是否显示
  showIndexColum: true,
  // 选中按钮功能
  showSelectColumn: true,

  // 决定ql-table header的标题
  title: '用户列表'
}
```

##### 如何将网路请求中的代码抽离出去

![image-20230212204947208](http://www.zhangqilong.cn/img/qlBlog_images/%E6%8A%80%E6%9C%AF/%E6%97%A5%E5%B8%B8%E7%A7%AF%E7%B4%AF/v3_ts_cms%E9%87%8D%E7%82%B9/image-20230212204947208.png)

> 图中为 user.vue 组件中的代码，是网络请求部分的代码，这些代码可以进行抽离
>
> 原因就是当我们进行网络请求的的时候，比如有一个 role 页面也需要进行网络请求，那么那个组件里面的网络请求代码逻辑和我们这里的代码逻辑几乎完全一致，就是请求的数据有所不同，但是我们依然可以将网络请求抽离出去，如何做呢

![image-20230212205222092](http://www.zhangqilong.cn/img/qlBlog_images/%E6%8A%80%E6%9C%AF/%E6%97%A5%E5%B8%B8%E7%A7%AF%E7%B4%AF/v3_ts_cms%E9%87%8D%E7%82%B9/image-20230212205222092.png)

> 实现思路：可以传入一个 pageName = "user" 或者 pageName = "role " 给封装好的网络请求，最后从中获取到的数据交给 User.vue 进行处理

![image-20230212210722303](http://www.zhangqilong.cn/img/qlBlog_images/%E6%8A%80%E6%9C%AF/%E6%97%A5%E5%B8%B8%E7%A7%AF%E7%B4%AF/v3_ts_cms%E9%87%8D%E7%82%B9/image-20230212210722303.png)

> 这样当我们开发一个页面的时候，就仅仅需要三个东西即可

![image-20230212211524708](http://www.zhangqilong.cn/img/qlBlog_images/%E6%8A%80%E6%9C%AF/%E6%97%A5%E5%B8%B8%E7%A7%AF%E7%B4%AF/v3_ts_cms%E9%87%8D%E7%82%B9/image-20230212211524708.png)

##### 改造之前代码

> 页面部分代码

`src\views\main\system\user\user.vue`

```vue
<template>
  <div class="user">
    <page-search :searchFormConfig="searchFormConfig"></page-search>
    <div class="content">
      <page-content :contentTableConfig="contentTableConfig" />
    </div>
  </div>
</template>

<script lang="ts">
import { defineComponent } from 'vue'
import QlTable from '@/base-ui/table'

// 引入封装好的组件
import PageContent from '@/components/page-content'
import PageSearch from '@/components/page-search'

// 导入封装好的配置文件
import { searchFormConfig } from './config/search.config'
import { contentTableConfig } from './config/content.config'

export default defineComponent({
  components: { PageSearch, QlTable, PageContent },
  name: 'user',
  setup() {
    return {
      searchFormConfig,
      contentTableConfig
    }
  }
})
</script>

<style scoped></style>
```

`src\components\page-content\src\page-content.vue`

```vue
<template>
  <div class="page-content">
    <ql-table :listData="userList" v-bind="contentTableConfig">
      <!-- 指定将 status 改为插槽，只改 status 对应的列数据 -->
      <template #status="scope">
        <el-button size="small" :type="scope.row.enable ? 'success' : 'danger'" plain>{{
          scope.row.enable ? '启用' : '禁用'
        }}</el-button>
      </template>
      <template #createAt="scope">
        {{ $filters.formatTime(scope.row.createAt) }}
      </template>
      <template #updateAt="scope">
        {{ $filters.formatTime(scope.row.updateAt) }}
      </template>
      <!-- 按钮写在 user.vue 中，意味着可以做权限控制，有的时候显示，有的时候不显示 -->
      <template #handler>
        <div class="handle-btns">
          <el-button icon="edit" size="small" type="text">编辑</el-button>
          <el-button icon="delete" size="small" type="danger">删除</el-button>
        </div>
      </template>

      <!-- 决定header 和 footer 长什么样子 -->
      <template #header></template>
      <template #footer></template>
      <!-- 按钮插槽 -->
      <template #headerHandler>
        <el-button type="primary">新建用户</el-button>
        <el-button icon="refresh">刷新</el-button>
      </template>
    </ql-table>
  </div>
</template>

<script lang="ts">
import { defineComponent, computed } from 'vue'

// 使用包装类型后的 useStore 会有类型提示
import { useStore } from '@/store'

import QlTable from '@/base-ui/table'
export default defineComponent({
  components: {
    QlTable
  },
  props: {
    contentTableConfig: {
      type: Object,
      require: true
    }
  },
  setup() {
    const store = useStore()
    // 调用 system 中的 action 这样可以从外面规定传入的参数
    store.dispatch('system/getPageListAction', {
      pageUrl: '/users/list', // 请求路径
      queryInfo: {
        offset: 0,
        size: 10
      }
    })
    // 从 store 中获取数据
    const userList = computed(() => store.state.system.userList)
    const userCount = computed(() => store.state.system.userCount)

    return {
      userList,
      userCount
    }
  }
})
</script>

<style scoped>
.page-content {
  padding: 20px;
  border-top: 20px solid #f5f5f5;
}
</style>
```

> 网络请求代码

`src\store\main\system\system.ts`

```ts
import type { IRootState } from '@/store/types'
import type { Module } from 'vuex'
import type { ISystemState } from './types'
import { getPageListData } from '@/service/main/system/system'
const systemModule: Module<ISystemState, IRootState> = {
  namespaced: true,
  state() {
    return {
      userList: [],
      userCount: []
    }
  },
  mutations: {
    // 修改数据
    changeUserList(state, userList) {
      state.userList = userList
    },
    changeUserCount(state, userCount) {
      state.userCount = userCount
    }
  },
  actions: {
    async getPageListAction({ commit }, payload: any) {
      // 获取到 user.vue 传入的参数，用于请求数据
      // console.log(payload.pageUrl)
      // console.log(payload.queryInfo)

      //1. 对页面进行发起请求网络数据
      const pageResult = await getPageListData(payload.pageUrl, payload.queryInfo)

      // console.log(pageResult)  // 数据

      // 对请求数据进行解构
      const { list, totalCount } = pageResult.data

      // 在 actions 里面提交 mutations 修改数据
      commit('changeUserList', list)
      commit('changeUserCount', totalCount)
    }
  }
}

export default systemModule
```

##### 改造之后代码

> 首先需要对 page-content 中代码进行修改，之前是固定死的请求 url 这里修改为可以改变的 url
>
> Table 组件部分

`src\components\page-content\src\page-content.vue`

```vue
<template>
  <div class="page-content">
    <ql-table :listData="userList" v-bind="contentTableConfig">
      <!-- 指定将 status 改为插槽，只改 status 对应的列数据 -->
      <template #status="scope">
        <el-button size="small" :type="scope.row.enable ? 'success' : 'danger'" plain>{{
          scope.row.enable ? '启用' : '禁用'
        }}</el-button>
      </template>
      <template #createAt="scope">
        {{ $filters.formatTime(scope.row.createAt) }}
      </template>
      <template #updateAt="scope">
        {{ $filters.formatTime(scope.row.updateAt) }}
      </template>
      <!-- 按钮写在 user.vue 中，意味着可以做权限控制，有的时候显示，有的时候不显示 -->
      <template #handler>
        <div class="handle-btns">
          <el-button icon="edit" size="small" type="text">编辑</el-button>
          <el-button icon="delete" size="small" type="danger">删除</el-button>
        </div>
      </template>

      <!-- 决定header 和 footer 长什么样子 -->
      <template #header></template>
      <template #footer></template>
      <!-- 按钮插槽 -->
      <template #headerHandler>
        <el-button type="primary">新建用户</el-button>
        <el-button icon="refresh">刷新</el-button>
      </template>
    </ql-table>
  </div>
</template>

<script lang="ts">
import { defineComponent, computed } from 'vue'

// 使用包装类型后的 useStore 会有类型提示
import { useStore } from '@/store'

import QlTable from '@/base-ui/table'
export default defineComponent({
  components: {
    QlTable
  },
  props: {
    contentTableConfig: {
      type: Object,
      require: true
    },
    // 接收一个 pageName 属性
    pageName: {
      type: String,
      require: true
    }
  },
  setup(props) {
    const store = useStore()
    // 调用 system 中的 action 这样可以从外面规定传入的参数
    store.dispatch('system/getPageListAction', {
      // pageUrl: '/users/list', // 请求路径
      pageName: props.pageName,             // 1. 在这里传入 pageName 信息用于在store中匹配路由
      queryInfo: {
        offset: 0,
        size: 10
      }
    })
    // 从 store 中获取数据
    const userList = computed(() => store.state.system.userList)
    const userCount = computed(() => store.state.system.userCount)

    return {
      userList,
      userCount
    }
  }
})
</script>

<style scoped>
.page-content {
  padding: 20px;
  border-top: 20px solid #f5f5f5;
}
</style>
```

> 修改路由配置信息

`src\store\main\system\system.ts`

```ts
import type { IRootState } from '@/store/types'
import type { Module } from 'vuex'
import type { ISystemState } from './types'
import { getPageListData } from '@/service/main/system/system'

// 定义一个 map
// const pageUrlMap = {
//   users: '/api/users/abc/list',
//   role: '/api/role/cba/list'
// }

const systemModule: Module<ISystemState, IRootState> = {
  namespaced: true,
  state() {
    return {
      userList: [],
      userCount: 0,
      roleCount: 0,
      roleList: []
    }
  },
  mutations: {
    // 修改数据
    changeUserList(state, userList) {
      state.userList = userList
    },
    changeUserCount(state, userCount) {
      state.userCount = userCount
    },
    changeRoleList(state, roleList) {
      state.roleList = roleList
    },
    changeRoleCount(state, roleCount) {
      state.roleCount = roleCount
    }
  },
  actions: {
    async getPageListAction({ commit }, payload: any) {
      // 动态pageUrl 的三种方式
      const pageName = payload.pageName
      // 如果公司接口写的特别规范，可以直接拼出来 pageUrl (user/list role/list boss/list)
      // const pageUrl = `${pageName}/list`

      // let pageUrl = pageUrlMap[pageName]
      let pageUrl = ''
      switch (pageName) {
        case 'user':
          pageUrl = '/users/list'
          break
        case 'role':
          pageUrl: '/role/list'
          break
      }

      // 动态pageUrl
      const pageResult = await getPageListData(pageUrl, payload.queryInfo)
      const { list, totalCount } = pageResult.data
      // 提交 mutations 修改数据 首字母大写
      commit(`change${pageName[0].toUpperCase() + pageName.substr(1)}List`, list)
      commit(`change${pageName[0].toUpperCase() + pageName.substr(1)}Count`, totalCount)

      // switch (pageName) {
      //   case 'user':
      //     commit('changeUserList', list)
      //     commit('changeUserCount', totalCount)
      //     break
      //   case 'role':
      //     commit('changeRoleList', list)
      //     commit('changeRoleCount', totalCount)
      //     break
      // }
    }
  }
}

export default systemModule
```

> TypeScript 配置信息，添加一个角色的类型

`src\store\main\system\types.ts`

```ts
export interface ISystemState {
  userList: any[] // 对于服务器返回的数据不对类型进行限制
  userCount: Number
  roleList: []
  roleCount: Number
}
```

> User 页面部分

`src\views\main\system\user\user.vue`

```vue
<template>
  <div class="user">
    <page-search :searchFormConfig="searchFormConfig"></page-search>
    <div class="content">
      <page-content :contentTableConfig="contentTableConfig" pageName="user" />
    </div>
  </div>
</template>

<script lang="ts">
import { defineComponent } from 'vue'
import QlTable from '@/base-ui/table'

// 引入封装好的组件
import PageContent from '@/components/page-content'
import PageSearch from '@/components/page-search'

// 导入封装好的配置文件
import { searchFormConfig } from './config/search.config'
import { contentTableConfig } from './config/content.config'

export default defineComponent({
  components: { PageSearch, QlTable, PageContent },
  name: 'user',
  setup() {
    return {
      searchFormConfig,
      contentTableConfig
    }
  }
})
</script>

<style scoped></style>
```

##### 快速搭建 Role 页面的 table

`src\views\main\system\role\role.vue`

```vue
<template>
  <div class="role">
    <!--3. 传入 pageName= "role"-->
    <page-content :contentTableConfig="contentTableConfig" pageName="role"> </page-content>
  </div>
</template>

<script lang="ts">
import { defineComponent } from 'vue'

//1. 封装好的列表组件
import PageContent from '@/components/page-content'
//2. 传入配置信息
import { contentTableConfig } from './config/content.config'
export default defineComponent({
  components: {
    PageContent
  },
  name: 'role',
  setup() {
    return {
      contentTableConfig
    }
  }
})
</script>

<style scoped></style>
```

> 配置信息

`src\views\main\system\role\config\content.config.ts`

```ts
// 对页面中固定死的东西进行抽离

// 用户管理内容配置
export const contentTableConfig = {
  // 针对于 userList 添加配置文件
  propList: [
    { prop: 'name', label: '角色名', minWidth: '100' },
    { prop: 'intro', label: '权限介绍', minWidth: '100' },
    { prop: 'createAt', label: '创建时间', minWidth: '100', slotName: 'createAt' },
    { prop: 'updateAt', label: '更新时间', minWidth: '100', slotName: 'updateAt' },
    { label: '操作', minWidth: '120', slotName: 'handler' }
  ],

  // 是否显示序号，默认显示，再次使用可以根据传入的 true 和 false 来决定是否显示
  showIndexColum: true,
  // 选中按钮功能
  showSelectColumn: true,

  // 决定ql-table header的标题
  title: '用户列表'
}
```

> 页面通用组件 page-content

`src\components\page-content\src\page-content.vue`

```vue
<template>
  <div class="page-content">
    <ql-table :listData="userList" v-bind="contentTableConfig">
      <!-- 指定将 status 改为插槽，只改 status 对应的列数据 -->
      <template #status="scope">
        <el-button size="small" :type="scope.row.enable ? 'success' : 'danger'" plain>{{
          scope.row.enable ? '启用' : '禁用'
        }}</el-button>
      </template>
      <template #createAt="scope">
        {{ $filters.formatTime(scope.row.createAt) }}
      </template>
      <template #updateAt="scope">
        {{ $filters.formatTime(scope.row.updateAt) }}
      </template>
      <!-- 按钮写在 user.vue 中，意味着可以做权限控制，有的时候显示，有的时候不显示 -->
      <template #handler>
        <div class="handle-btns">
          <el-button icon="edit" size="small" type="text">编辑</el-button>
          <el-button icon="delete" size="small" type="danger">删除</el-button>
        </div>
      </template>

      <!-- 决定header 和 footer 长什么样子 -->
      <template #header></template>
      <template #footer></template>
      <!-- 按钮插槽 -->
      <template #headerHandler>
        <el-button type="primary">新建用户</el-button>
        <el-button icon="refresh">刷新</el-button>
      </template>
    </ql-table>
  </div>
</template>

<script lang="ts">
import { defineComponent, computed } from 'vue'

// 使用包装类型后的 useStore 会有类型提示
import { useStore } from '@/store'

import QlTable from '@/base-ui/table'
export default defineComponent({
  components: {
    QlTable
  },
  props: {
    contentTableConfig: {
      type: Object,
      require: true
    },
    // 接收一个 pageName 属性
    pageName: {
      type: String,
      require: true
    }
  },
  setup(props) {
    const store = useStore()
    // 调用 system 中的 action 这样可以从外面规定传入的参数
    store.dispatch('system/getPageListAction', {
      // pageUrl: '/users/list', // 请求路径
      pageName: props.pageName,
      queryInfo: {
        offset: 0,
        size: 10
      }
    })

    // 从 store 中获取数据
    const userList = computed(() => store.state.system.userList)
    const userCount = computed(() => store.state.system.userCount)

    return {
      userList,
      userCount
    }
  }
})
</script>

<style scoped>
.page-content {
  padding: 20px;
  border-top: 20px solid #f5f5f5;
}
</style>
```

> 配置网络请求

`src\store\main\system\system.ts`

```ts
import type { IRootState } from '@/store/types'
import type { Module } from 'vuex'
import type { ISystemState } from './types'
import { getPageListData } from '@/service/main/system/system'

// 定义一个 map
// const pageUrlMap = {
//   users: '/api/users/abc/list',
//   role: '/api/role/cba/list'
// }

const systemModule: Module<ISystemState, IRootState> = {
  namespaced: true,
  state() {
    return {
      userList: [],
      userCount: 0,
      roleCount: 0,
      roleList: []
    }
  },
  mutations: {
    // 修改数据
    changeUserList(state, userList) {
      state.userList = userList
    },
    changeUserCount(state, userCount) {
      state.userCount = userCount
    },
    changeRoleList(state, roleList) {
      state.roleList = roleList
    },
    changeRoleCount(state, roleCount) {
      state.roleCount = roleCount
    }
  },
  // getter1 在 page-content 第二步
  getters: {
    // 配置 getters
    pageListData(state) {
      // return state.userList
      // getter 可以返回一个函数
      return (pageName: string) => {
        switch (pageName) {
          case 'user':
            return state.userList
          case 'role':
            return state.roleList
        }
      }
    }
  },
  actions: {
    async getPageListAction({ commit }, payload: any) {
      // 1.获取pageUrl
      const pageName = payload.pageName
      const pageUrlName = payload.pageName === 'user' ? 'users' : payload.pageName
      const pageUrl = `/${pageUrlName}/list`

      // 动态pageUrl
      const pageResult = await getPageListData(pageUrl, payload.queryInfo)
      const { list, totalCount } = pageResult.data
      // 提交 mutations 修改数据 首字母大写
      commit(`change${pageName[0].toUpperCase() + pageName.substr(1)}List`, list)
      commit(`change${pageName[0].toUpperCase() + pageName.substr(1)}Count`, totalCount)

      // switch (pageName) {
      //   case 'user':
      //     commit('changeUserList', list)
      //     commit('changeUserCount', totalCount)
      //     break
      //   case 'role':
      //     commit('changeRoleList', list)
      //     commit('changeRoleCount', totalCount)
      //     break
      // }
    }
  }
}

export default systemModule
```

##### 对 page -search的优化 (重置，数据的二次处理)

> 当我们写完 role 组件的时候，会发现里面的数据对应的字段可能有问题
>
> user 组件中的字段是 

![image-20230213105132131](http://www.zhangqilong.cn/img/qlBlog_images/%E6%8A%80%E6%9C%AF/%E6%97%A5%E5%B8%B8%E7%A7%AF%E7%B4%AF/v3_ts_cms%E9%87%8D%E7%82%B9/image-20230213105132131.png)

> 而 role 组件中的字段是

![image-20230213105221014](http://www.zhangqilong.cn/img/qlBlog_images/%E6%8A%80%E6%9C%AF/%E6%97%A5%E5%B8%B8%E7%A7%AF%E7%B4%AF/v3_ts_cms%E9%87%8D%E7%82%B9/image-20230213105221014.png)

> 但是之前我们配置文件中的内容，把这些字段规定死了，有没有一种解决办法是动态匹配这些字段的呢？

修改之前配置文件

`src\components\page-search\src\page-search.vue`

```vue
<template></template>

<script lang="ts">
  setup() {
    const formData = ref({
      id: '',
      password: 
      sport: '',
      createTime: ''
    })
    return {
      formData
    }
  }
})
</script>

```

修改之后配置文件

`src\components\page-search\src\page-search.vue`

```vue
<template></template>
<script lang="ts">
  setup(props) {
    // 优化一：formData 中的属性应该动态来决定
    // 双向绑定的属性应该是由配置文件的 field 来决定
    // 所以 formData 里面的数据不能写死，应该由配置文件来决定
    const formItems = props.searchFormConfig?.formItems ?? [] // 如果为空则默认空数据
    const formOriginData: any = {}
    for (const item of formItems) {
      formOriginData[item.field] = ''
    }
    const formData = ref(formOriginData)

    // 优化二：当用户点击重置
    const handleResetClick = () => {
      // 将设置的值赋值为原始对象
      formData.value = formOriginData
    }
    return {
      formData,
      handleResetClick
    }
  }
})
</script>
```

> 但是点击重置按钮的话，数据发生了变化，但是视图没有更新，最简单的做法就是 watch 监听数据，在表单组价中进行修改

`src\base-ui\form\src\form.vue`

```vue
<template>
  <div class="ql-form">
    <div class="header">
      <slot name="header"></slot>
    </div>
    <el-form :label-width="labelWidth">
      <el-row>
        <template v-for="item in formItems" key="item.label">
          <el-col v-bind="collLayout">
            <!-- 直接使用 props 传入的 itemStyle -->
            <el-form-item :label="item.label" :rules="item.rules" :style="itemStyle">
              <template v-if="item.type === 'input' || item.type === 'password'">
                <el-input
                  :placeholder="item.placeholder"
                  v-bind="item.otherOptions"
                  :show-password="item.type === 'password'"
                  v-model="formData[`${item.field}`]"
                />
              </template>
              <template v-else-if="item.type === 'select'">
                <el-select
                  :placeholder="item.placeholder"
                  style="width: 100%"
                  v-bind="item.otherOptions"
                  v-model="formData[`${item.field}`]"
                >
                  <el-option
                    v-for="option in item.options"
                    :key="option.value"
                    :value="option.value"
                    >{{ option.title }}</el-option
                  >
                </el-select>
              </template>
              <template v-else-if="item.type === 'datepicker'">
                <!-- 直接绑定其他属性 -->
                <el-date-picker
                  v-model="formData[`${item.field}`]"
                  style="width: 100%"
                  v-bind="item.otherOptions"
                />
              </template>
            </el-form-item>
          </el-col>
        </template>
      </el-row>
    </el-form>
    <div class="footer">
      <slot name="footer"></slot>
    </div>
  </div>
</template>

<script lang="ts">
import { computed, defineComponent, ref, watch } from 'vue'
import type { PropType } from 'vue'
import type { IFormItem } from '../types'
export default defineComponent({
  props: {
    // 父组件使用子组件时候 v-model 传入数据
    modelValue: {
      type: Object,
      require: true
    },
    formItems: {
      // [{label,value}] 确定数组里面的东西
      type: Array as PropType<IFormItem[]>,
      // 默认值注意点：对象和数组的高级类型需要写成箭头函数
      default: () => [] // 默认值空数组
    },
    labelWidth: {
      type: String,
      default: '100px'
    },
    itemStyle: {
      type: Object,
      // 默认的 padding
      default: () => ({ padding: '10px 40px' })
    },
    // 响应式
    collLayout: {
      type: Object,
      default: () => ({
        xl: 8, //>1920 的屏幕占4个
        lg: 8,
        md: 12,
        sm: 24,
        xs: 24
      })
    }
  },
  // emit 发送一个事件之后用 v-model="formData" 接收
  emits: ['update:modelValue'],
  setup(props, { emit }) {
    // 将对象拷贝一份放入新的对象中，当数据发生改变的时候通过 emit 发送出去
    // 这种方式实现的双向绑定，而不是通过引用去修改
    const formData = ref({ ...props.modelValue })
    // 监听 formData,deep = true 当对象中某一个属性发生改变也会监听到发出事件

    // 使用 watch 监听 modelValue 的变化，重新对 formData 赋值引起视图更新
    watch(
      () => props.modelValue,
      (newValue) => {
        formData.value = { ...newValue }
      }
    )

    watch(
      formData,
      (newValue) => {
        // console.log(newValue)
        emit('update:modelValue', newValue)
      },
      {
        deep: true
      }
    )
    return {
      formData
    }
  }
})
</script>

<style scoped lang="less">
.ql-form {
  padding-top: 22px;
}
</style>
```

##### 简单总结

![image-20230213134708264](http://www.zhangqilong.cn/img/qlBlog_images/%E6%8A%80%E6%9C%AF/%E6%97%A5%E5%B8%B8%E7%A7%AF%E7%B4%AF/v3_ts_cms%E9%87%8D%E7%82%B9/image-20230213134708264.png)

> 首先有自己封装的组件 page-search page-search 组件依赖于 HyForm 组件，HyForm 还依赖于其他的小组，ElInput、ElSelect、ElDatePicker 组件，
>
> 达到一个目的，在 page-content 中定义了一个复杂数据类型 formData里面定义了许多数据比如(name,id) 想要动态绑定到、ElInput、ElSelect、ElDatePicker 组件上面，就必须要经过 HyForm，因为HyForm 中引用了小组件，那么就需要使用双向绑定，

> 如何做是双向绑定？
>
> 1. 首先将 formData 中数据绑定到 HyForm 上面，通过 v-model，如果直接使用 v-model 传入数据的话，那么在子组件 HyForm 中 props 中的 modelValue 可以获取到 formData 数据，
> 2. 一种方式是可以直接通过，formData.属性名 获取数据并且修改外界的属性值 比如 formData.name ="123" 就可以直接修改父组件的值，但是这样就违背了单项数据流的原则，这样的话就会在 template 中报一个警告，当然可以通过修改 eslint 解决
> 3. 另一种方式就是，在 HyForm 中对 v-model 传入的数据进行浅拷贝，浅拷贝之后的数据叫做 内部formData，然后把内部的对象绑定到 ElInput、ElSelect、ElDatePicker 组件上面，并且配置文件中的数据每个都是不同的，我们就需要在 page-search 中修改，这样每一个组件中对用的 formData 就是不同的

> 问题二：为什么在 page-config 中配置的重置按钮没有生效
>
> 我们在 page-config 中设置重置按钮

`src\components\page-search\src\page-search.vue`

```vue
<template>
  <div class="page-search">
    <div class="search">
      <!-- <ql-form
        :form-items="formItems"
        :labelWidth="labelWidth"
        :itemStyle="itemStyle"
        :colLayout="colLayout"
      /> -->
      <!-- <ql-form v-bind="searchFormConfig" :formData="formData" /> -->
      <!-- 方案二：v-model -->
      <ql-form v-bind="searchFormConfig" v-model="formData">
        <!-- 使用插槽 在组件中定义 header 的 slot-->
        <!-- <template #header>
          <h1 class="header">高级检索</h1>
        </template> -->
        <template #footer>
          <div class="handle-btns">
            <el-button type="primary" icon="refresh" @click="handleResetClick">重置</el-button>
            <el-button type="primary" icon="search">搜索</el-button>
          </div>
        </template>
      </ql-form>
    </div>
  </div>
</template>

<script lang="ts">
import { defineComponent, ref } from 'vue'
import QlForm from '@/base-ui/form'

export default defineComponent({
  props: {
    searchFormConfig: {
      type: Object,
      require: true
    }
  },
  components: {
    QlForm
  },
  setup(props) {
    // 优化一：formData 中的属性应该动态来决定
    // 双向绑定的属性应该是由配置文件的 field 来决定
    // 所以 formData 里面的数据不能写死，应该由配置文件来决定
    const formItems = props.searchFormConfig?.formItems ?? [] // 如果为空则默认空数据
    const formOriginData: any = {}
    for (const item of formItems) {
      formOriginData[item.field] = ''
    }
    const formData = ref(formOriginData)

    // 优化二：当用户点击重置
    const handleResetClick = () => {
      // 将设置的值赋值为原始对象
      formData.value = formOriginData
    }
    return {
      formData,
      handleResetClick
    }
  }
})
</script>

<style scoped>
.handle-btns {
  text-align: right;
  padding: 0 50px 20px 0;
}
</style>
```

> 这里为什么将数据重置为原始对象没有生效呢？
>
> 原因就是当我们进行点击重置按钮的时候，我们 HyForm 中的数据，对 formData 进行了一层浅拷贝

`src\base-ui\form\src\form.vue`

```vue
<template>

</template>

<script lang="ts">
  emits: ['update:modelValue'],
  setup(props, { emit }) {
    // 将对象拷贝一份放入新的对象中，当数据发生改变的时候通过 emit 发送出去
    // 这种方式实现的双向绑定，而不是通过引用去修改
    const formData = ref({ ...props.modelValue })
    // 监听 formData,deep = true 当对象中某一个属性发生改变也会监听到发出事件

    // 使用 watch 监听 modelValue 的变化，重新对 formData 赋值引起视图更新
    watch(
      () => props.modelValue,
      (newValue) => {
        formData.value = { ...newValue }
      }
    )

    watch(
      formData,
      (newValue) => {
        // console.log(newValue)
        emit('update:modelValue', newValue)
      },
      {
        deep: true
      }
    )
    return {
      formData
    }
  }
})
</script>

<style scoped lang="less">
.ql-form {
  padding-top: 22px;
}
</style>
```

> 当进行了浅拷贝之后的数据，对 HyForm 中的 formData 进行了初始化
>
> `const formData = ref({ ...props.modelValue })`
> 这样当我们在 page-content 中修改数据的话，HyForm 中的 formData 对于 page-content 中v-model 传入的数据是没有依赖的，依赖于HyForm 中浅拷贝出来的数据，
>
> 因为`const formData = ref({ ...props.modelValue })` 之后，虽然 modelValue  发生了改变，但是 HyForm 中的formData  并没有对 modelValue  有直接性的依赖，因为拷贝，所以两者没有影响
>
> 如何解决
>
> 第一种方式使用 watch 进行监听里面的数据变化，不能使用 computed 对浅拷贝的数据进行包裹，因为 computed 之后的确数据会对 modelValue 产生依赖，但是由于下面还有一个 watch，当数据发生改变之后，watch就会发送 emit 去通知修改数据，数据发生改变之后 HyForm 中的数据还是改变了，就会产生递归
>
> 第一种方式就是新增一个 watch 监听数据

`src\base-ui\form\src\form.vue`

```vue
<template>
</template>

<script lang="ts">
  emits: ['update:modelValue'],
  setup(props, { emit }) {
    // 将对象拷贝一份放入新的对象中，当数据发生改变的时候通过 emit 发送出去
    // 这种方式实现的双向绑定，而不是通过引用去修改
    const formData = ref({ ...props.modelValue })
    // 监听 formData,deep = true 当对象中某一个属性发生改变也会监听到发出事件

    // 使用 watch 监听 modelValue 的变化，重新对 formData 赋值引起视图更新
    watch(
      () => props.modelValue,
      (newValue) => {
        formData.value = { ...newValue }
      }
    )

    watch(
      formData,
      (newValue) => {
        // console.log(newValue)
        emit('update:modelValue', newValue)
      },
      {
        deep: true
      }
    )
    return {
      formData
    }
  }
})
</script>

<style scoped lang="less">
.ql-form {
  padding-top: 22px;
}
</style>
```

> 重置按钮第二种方式
> 通过找到初始化数据和 formData 中数据相同的 key 来修改数据，因为是浅拷贝，所以 formData中属性值发生改变，那么对象中也会跟着一起改变

`src\components\page-search\src\page-search.vue`

```vue
<template>
<script lang="ts">
import { defineComponent, ref } from 'vue'
import QlForm from '@/base-ui/form'

export default defineComponent({
  props: {
    searchFormConfig: {
      type: Object,
      require: true
    }
  },
  components: {
    QlForm
  },
  setup(props) {
    // 优化一：formData 中的属性应该动态来决定
    // 双向绑定的属性应该是由配置文件的 field 来决定
    // 所以 formData 里面的数据不能写死，应该由配置文件来决定
    const formItems = props.searchFormConfig?.formItems ?? [] // 如果为空则默认空数据
    const formOriginData: any = {}
    for (const item of formItems) {
      formOriginData[item.field] = ''
    }
    const formData = ref(formOriginData)

    // 优化二：当用户点击重置
    const handleResetClick = () => {
      // 将设置的值赋值为原始对象
      // formData.value = formOriginData
      // 重置第二种方式，通过找到初始化数据和 formData 中数据相同的 key 来修改数据
      // 因为是浅拷贝，所以 formData中属性值发生改变，那么对象中也会跟着一起改变
      for (const key in formOriginData) {
        formData.value[`${key}`] = formOriginData[key]
      }
    }
    return {
      formData,
      handleResetClick
    }
  }
})
</script>

<style scoped>
</style>
```

> 第二种方式浅拷贝的地方无需发生改变

`src\base-ui\form\src\form.vue`

```vue
<template>
</template>

<script lang="ts">
  emits: ['update:modelValue'],
  setup(props, { emit }) {
    // 将对象拷贝一份放入新的对象中，当数据发生改变的时候通过 emit 发送出去
    // 这种方式实现的双向绑定，而不是通过引用去修改
    const formData = ref({ ...props.modelValue })
    // 监听 formData,deep = true 当对象中某一个属性发生改变也会监听到发出事件

    // 重置第一种方式：使用 watch 监听 modelValue 的变化，重新对 formData 赋值引起视图更新
    // watch(
    //   () => props.modelValue,
    //   (newValue) => {
    //     formData.value = { ...newValue }
    //   }
    // )

    watch(
      formData,
      (newValue) => {
        // console.log(newValue)
        emit('update:modelValue', newValue)
      },
      {
        deep: true
      }
    )
    return {
      formData
    }
  }
})
</script>
```

##### 搜索按钮实现

> 思路：当点击搜索按钮之后触发handleQuery事件，拿到数据之后需要重新发送网络请求，来重新获取数据

> 而默认情况下，请求数据是在 page-content 中的 setup 中，但是 setup 里面代码仅仅只能一次网络请求，所以需要将网络请求的代码封装进函数中，（setup仅仅会执行一次，有点类似组件 create ）

> 实现思路

![image-20230213153838583](http://www.zhangqilong.cn/img/qlBlog_images/%E6%8A%80%E6%9C%AF/%E6%97%A5%E5%B8%B8%E7%A7%AF%E7%B4%AF/v3_ts_cms%E9%87%8D%E7%82%B9/image-20230213153838583.png)

> 1.当在 page-search 中发生点击事件(重置或者搜索)，那么就需要将事件传递给 user 组件，因为 user 组件是 page-search 组件和 page-search 组件的父组件，再在父组件中调用 page-content 中的 getPageData 事件

> 2. 在 page-search 组件中，创建自定义事件，在父组件 user 中 template 组件上接收自定义事件

`src\components\page-search\src\page-search.vue`

```vue
<template>
</template>

<script lang="ts">
export default defineComponent({
  props: {
    searchFormConfig: {
      type: Object,
      require: true
    }
  },
  components: {
    QlForm
  },
  //1. 所有需要发出到 user 组件的事件
  emits: ['resetBtnClick', 'queryBtnClick'],
  //2. 拿到 emit
  setup(props, { emit }) {
    // 优化一：formData 中的属性应该动态来决定
    // 双向绑定的属性应该是由配置文件的 field 来决定
    // 所以 formData 里面的数据不能写死，应该由配置文件来决定
    const formItems = props.searchFormConfig?.formItems ?? [] // 如果为空则默认空数据
    const formOriginData: any = {}
    for (const item of formItems) {
      formOriginData[item.field] = ''
    }
    const formData = ref(formOriginData)

    // 优化二：当用户点击重置
    const handleResetClick = () => {
      // 将设置的值赋值为原始对象
      // formData.value = formOriginData
      // 重置第二种方式，通过找到初始化数据和 formData 中数据相同的 key 来修改数据
      // 因为是浅拷贝，所以 formData中属性值发生改变，那么对象中也会跟着一起改变
      for (const key in formOriginData) {
        formData.value[`${key}`] = formOriginData[key]
      }
      // 3.重置按钮不需要参数
      emit('resetBtnClick')
    }

    // 优化三： 当用户点击搜索
    const handleQuery = () => {
      //4. 需要参数，收集所有 form 中的数据传入
      // 5.在 user 组件上监听事件 @resetBtnClick ="handleResetClick" @queryBtnClick="handleQueryClick"
      emit('queryBtnClick', formData.value)
    }
    return {
      formData,
      handleResetClick,
      handleQuery
    }
  }
})
</script>

<style scoped>
</style>
```

> 父组件上接收到自定义方法

`src\views\main\system\user\user.vue`

```vue
<template>
  <div class="user">
     <!-- 接收子组件上传入的自定义事件 -->
    <page-search
      :searchFormConfig="searchFormConfig"
      @resetBtnClick="handleResetClick"
      @queryBtnClick="handleQueryClick"
    ></page-search>
    <div class="content">
      <page-content :contentTableConfig="contentTableConfig" pageName="user" />
    </div>
  </div>
</template>

<script lang="ts">
import { defineComponent } from 'vue'
import QlTable from '@/base-ui/table'

// 引入封装好的组件
import PageContent from '@/components/page-content'
import PageSearch from '@/components/page-search'

// 导入封装好的配置文件
import { searchFormConfig } from './config/search.config'
import { contentTableConfig } from './config/content.config'

export default defineComponent({
  components: { PageSearch, QlTable, PageContent },
  name: 'user',
  setup() {
    // 实现重置按钮
    const handleResetClick = () => {
     // 这里是为了实现调用另外一个 page-content 中的方法
    }
    // 实现搜索按钮逻辑
    const handleQueryClick = (queryInfo: any) => {
      //不实现具体逻辑，这里是为了实现调用另外一个 page-content 中的方法
    }
    return {
      searchFormConfig,
      contentTableConfig,
      handleQueryClick,
      handleResetClick
    }
  }
})
</script>

<style scoped></style>
```

> 封装 hooks 抽离逻辑

`src\hooks\usePageSearch.ts`

```ts
import { ref } from 'vue'
import PageContent from '@/components/page-content'

export function usePageSearch() {
  // 获取页面 page-content 组件
  const pageContentRef = ref<InstanceType<typeof PageContent>>()
  // 实现重置按钮
  const handleResetClick = () => {
    // 这里没有参数
    pageContentRef.value?.getPageData()
  }
  // 实现搜索按钮逻辑
  const handleQueryClick = (queryInfo: any) => {
    //不实现具体逻辑，这里是为了实现调用另外一个 page-content 中的方法
    pageContentRef.value?.getPageData(queryInfo)
  }
  return [pageContentRef, handleResetClick, handleQueryClick]
}
```

`src\views\main\system\user\user.vue`

```vue
<template>
  <div class="user">
    <page-search
      :searchFormConfig="searchFormConfig"
      @resetBtnClick="handleResetClick"
      @queryBtnClick="handleQueryClick"
    ></page-search>
    <div class="content">
      <page-content ref="pageContentRef" :contentTableConfig="contentTableConfig" pageName="user" />
    </div>
  </div>
</template>

<script lang="ts">
import { defineComponent, ref } from 'vue'
import QlTable from '@/base-ui/table'

// 引入封装好的组件
import PageContent from '@/components/page-content'
import PageSearch from '@/components/page-search'

// 导入封装好的配置文件
import { searchFormConfig } from './config/search.config'
import { contentTableConfig } from './config/content.config'

// 导入公共方法
import { usePageSearch } from '@/hooks/usePageSearch'
export default defineComponent({
  components: {
    PageSearch,
    QlTable,
    PageContent
  },
  name: 'user',
  setup() {
    // 使用hooks 注意顺序
    const [pageContentRef, handleResetClick, handleQueryClick] = usePageSearch()
    return {
      searchFormConfig,
      contentTableConfig,
      handleQueryClick,
      handleResetClick,
      pageContentRef
    }
  }
})
</script>
<style scoped></style>
```

##### 使用组件时候将 count 传入

> 当我们使用组件的时候，可以将 dataCount 从 store 中获取到，dataCount 存储在 store 的 state 中，可以设置一个 getters 来获取 dataCount 从而可以在 page-count 中获取到

`src\store\main\system\system.ts`

```ts
import type { IRootState } from '@/store/types'
import type { Module } from 'vuex'
import type { ISystemState } from './types'
import { getPageListData } from '@/service/main/system/system'

const systemModule: Module<ISystemState, IRootState> = {
  namespaced: true,
  state() {
    return {
      userList: [],
      userCount: 0,
      roleCount: 0,
      roleList: []
    }
  },
  mutations: {
    // 修改数据
    changeUserList(state, userList) {
      state.userList = userList
    },
    changeUserCount(state, userCount) {
      state.userCount = userCount
    },
    changeRoleList(state, roleList) {
      state.roleList = roleList
    },
    changeRoleCount(state, roleCount) {
      state.roleCount = roleCount
    }
  },
  // 在 getters 里面封装 get 间接获取 state 里面的数据
  // getter1 在 page-content 第二步
  getters: {
    // 配置 getters
    pageListData(state) {
      // return state.userList
      // getter 可以返回一个函数，获取 listData 数据列表
      return (pageName: string) => {
        return (state as any)[`${pageName}List`]
      }
    },
    // 获取 dataCount 数据总数列表
    pageListCount(state) {
      return (pageName: string) => {
        return (state as any)[`${pageName}Count`]
      }
    }
  },
  actions: {
    async getPageListAction({ commit }, payload: any) {
      // 1.获取pageUrl
      const pageName = payload.pageName
      const pageUrlName = payload.pageName === 'user' ? 'users' : payload.pageName
      const pageUrl = `/${pageUrlName}/list`

      // 动态pageUrl
      const pageResult = await getPageListData(pageUrl, payload.queryInfo)
      const { list, totalCount } = pageResult.data
      // 提交 mutations 修改数据 首字母大写
      commit(`change${pageName[0].toUpperCase() + pageName.substr(1)}List`, list)
      commit(`change${pageName[0].toUpperCase() + pageName.substr(1)}Count`, totalCount)
    }
  }
}

export default systemModule
```

> 在组件中使用数据

`src\components\page-content\src\page-content.vue`

```vue
<template>
  <div class="page-content">
    <ql-table :listData="dataList" :listCount="dataCount" v-bind="contentTableConfig">
    </ql-table>
  </div>
</template>

<script lang="ts">
import { defineComponent, computed } from 'vue'

// 使用包装类型后的 useStore 会有类型提示
import { useStore } from '@/store'

import QlTable from '@/base-ui/table'
export default defineComponent({
  components: {
    QlTable
  },
  props: {
    contentTableConfig: {
      type: Object,
      require: true
    },
    // 接收一个 pageName 属性
    pageName: {
      type: String,
      require: true
    }
  },
  setup(props) {
    const store = useStore()
    // 调用 system 中的 action 这样可以从外面规定传入的参数

    // 发送网络请求 默认是空对象，没有传入默认空对象
    const getPageData = (queryInfo: any = {}) => {
      store.dispatch('system/getPageListAction', {
        // pageUrl: '/users/list', // 请求路径
        pageName: props.pageName,
        queryInfo: {
          offset: 0,
          size: 10,
          ...queryInfo // 收集到的表单数据，带条件的查询，关键字模糊查询
        }
      })
    }
    getPageData()

    // 从 vuex 中获取数据
    // const userList = computed(() => store.state.system.userList)
    // const userCount = computed(() => store.state.system.userCount)
    // getter2   这样获取的就是data list  getters 里面返回的是一个函数，传入参数
    const dataList = computed(() => store.getters[`system/pageListData`](props.pageName))
    const dataCount = computed(() => store.getters[`system/pageListCount`](props.pageName))

    return {
      dataList,
      getPageData, // return 出去父组件用 组件ref.value.方法调用
      dataCount
    }
  }
})
</script>

<style scoped>
.page-content {
  padding: 20px;
  border-top: 20px solid #f5f5f5;
}
</style>
```

> 传入到 base-ui 中的 qlTable 中

`src\base-ui\table\src\table.vue`

```vue
<template>
  <div class="ql-table">
    <!-- 给 ql-table 添加一个分页的功能 -->
    <div class="footer">
      <slot name="footer">
        <el-pagination
          :current-page="currentPage2"
          :page-size="10"
          :page-sizes="[10, 20, 30, 40]"
          :small="small"
          layout="total, sizes, prev,pager,next,jumper"
          :total="listCount"
          @size-change="handleSizeChange"
          @current-change="handleCurrentChange"
        />
      </slot>
    </div>
  </div>
</template>

<script lang="ts">
import { defineComponent } from 'vue'

export default defineComponent({
  props: {
    listData: {
      type: Array,
      require: true
    },
    propList: {
      type: Array,
      require: true
    },
    //是否显示序号列，默认不显示
    showIndexColum: {
      type: Boolean,
      default: false
    },
    // 是否显示选中按钮
    showSelectColumn: {
      type: Boolean,
      default: false
    },
    // ql-table title标题
    title: {
      type: String,
      default: ''
    },
    // 数据总数
    listCount: {
      type: Number,
      require: true
    }
  },
  emits: ['selectionChange'],
  setup(props, { emit }) {
    // 当选中按钮生效的时候，触发的事件
    const handleSelectionChange = (value: any) => {
      // console.log(value)  // 获取到的数据
      // 当选中的数据发送到上一层，对数据进行处理
      emit('selectionChange', value)
    }
    return {
      handleSelectionChange
    }
  }
})
</script>

<style scoped lang="less">
</style>
```

##### 分页功能的具体实现

> 实现思路

![image-20230213181320877](http://www.zhangqilong.cn/img/qlBlog_images/%E6%8A%80%E6%9C%AF/%E6%97%A5%E5%B8%B8%E7%A7%AF%E7%B4%AF/v3_ts_cms%E9%87%8D%E7%82%B9/image-20230213181320877.png)

![image-20230213181440475](http://www.zhangqilong.cn/img/qlBlog_images/%E6%8A%80%E6%9C%AF/%E6%97%A5%E5%B8%B8%E7%A7%AF%E7%B4%AF/v3_ts_cms%E9%87%8D%E7%82%B9/image-20230213181440475.png)

![image-20230213181459068](http://www.zhangqilong.cn/img/qlBlog_images/%E6%8A%80%E6%9C%AF/%E6%97%A5%E5%B8%B8%E7%A7%AF%E7%B4%AF/v3_ts_cms%E9%87%8D%E7%82%B9/image-20230213181459068.png)

这两个数据应该是双向绑定的

> 首先需要将 pageSize 和 currentPage 数据从 page-content 传入到 table 组件中
>
> 在 page-content 中用 ref 定义数据，并且通过 v-model 将数据传入到 qlForm 中
>
> 注意 v-model 传入的数据是可以起别名的

`src\components\page-content\src\page-content.vue`

```vue
<template>
  <div class="page-content">
//第二步：将 pageInfo 传入到组件中
    <ql-table
      :listData="dataList"
      :listCount="dataCount"
      v-bind="contentTableConfig"
      v-model:page="pageInfo"
    >
    </ql-table>
  </div>
</template>

<script lang="ts">
import { defineComponent, computed, ref } from 'vue'
  setup(props) {
    const store = useStore()
    // 调用 system 中的 action 这样可以从外面规定传入的参数

//第一步：双向绑定 pageInfo
    const pageInfo = ref({ currentPage: 0, pageSize: 20 })

    // 发送网络请求 默认是空对象，没有传入默认空对象
    const getPageData = (queryInfo: any = {}) => {
      store.dispatch('system/getPageListAction', {
        // pageUrl: '/users/list', // 请求路径
        pageName: props.pageName,
        queryInfo: {
          offset: 0,
          size: 10,
          ...queryInfo // 收集到的表单数据，带条件的查询，关键字模糊查询
        }
      })
    }
    getPageData()

    // 从 vuex 中获取数据

    // const userList = computed(() => store.state.system.userList)
    // const userCount = computed(() => store.state.system.userCount)
    // getter2   这样获取的就是data list  getters 里面返回的是一个函数，传入参数
    const dataList = computed(() => store.getters[`system/pageListData`](props.pageName))
    const dataCount = computed(() => store.getters[`system/pageListCount`](props.pageName))

    return {
      dataList,
      getPageData, // return 出去父组件用 组件ref.value.方法调用
      dataCount,
      pageInfo
    }
  }
})
</script>

<style scoped>
</style>
```

> 在 qlForm 组件中接收传入的数据，并且将其绑定在分页组件上面

`src\base-ui\table\src\table.vue`

```vue
<template>
  <div class="ql-table">
    <!-- 给 ql-table 添加一个分页的功能 -->
    <div class="footer">
      <slot name="footer">
        <el-pagination
          :current-page="page.currentPage"
          :page-size="page.pageSize"
          :page-sizes="[10, 20, 30, 40]"
          :small="small"
          layout="total, sizes, prev,pager,next,jumper"
          :total="listCount"
          @size-change="handleSizeChange"
          @current-change="handleCurrentChange"
        />
      </slot>
  </div>
</template>

<script lang="ts">
import { defineComponent } from 'vue'

export default defineComponent({
  props: {
    // 从 page-content 中接收书双向绑定传入的数据
    page: {
      type: Object,
      // 给一个默认值
      default: () => ({ currentPage: 0, pageSize: 10 })
    }
  },
  emits: ['selectionChange'],
  setup(props, { emit }) {
    // 当选中按钮生效的时候，触发的事件
    const handleSelectionChange = (value: any) => {
      // console.log(value)  // 获取到的数据
      // 当选中的数据发送到上一层，对数据进行处理
      emit('selectionChange', value)
    }
    return {
      handleSelectionChange
    }
  }
})
</script>

<style scoped lang="less">
</style>
```

> 当 qlTable  组件中数据发生改变的时候，也就是用户点击了切换页码的操作，需要在 qlTable 中定义方法handleSizeChange 和 handleCurrentChange 

`src\base-ui\table\src\table.vue`

```vue
<template>
  <div class="ql-table">
    <!-- 给table页面添加一个header 用于显示新增按钮和用户列表 -->
    <div class="header">
    </el-table>
    <!-- 给 ql-table 添加一个分页的功能 -->
    <div class="footer">
      <slot name="footer">
        <el-pagination
          :current-page="page.currentPage"
          :page-size="page.pageSize"
          :page-sizes="[10, 20, 30, 40]"
          :small="small"
          layout="total, sizes, prev,pager,next,jumper"
          :total="listCount"
          @size-change="handleSizeChange"
          @current-change="handleCurrentChange"
        />
      </slot>
    </div>
  </div>
</template>

<script lang="ts">
import { defineComponent } from 'vue'

export default defineComponent({
  props: {
    // 从 page-content 中接收书双向绑定传入的数据
    page: {
      type: Object,
      // 给一个默认值
      default: () => ({ currentPage: 0, pageSize: 10 })
    }
  },
  emits: ['selectionChange', 'update:page', 'update:size'],
  setup(props, { emit }) {
    // 当选中按钮生效的时候，触发的事件
    const handleSelectionChange = (value: any) => {
      // console.log(value)  // 获取到的数据
      // 当选中的数据发送到上一层，对数据进行处理
      emit('selectionChange', value)
    }
    // 当页码发生变化
    const handleCurrentChange = (currentPage: number) => {
      emit('update:page', { ...props.page, currentPage })
    }

    // 页大小发生变化
    const handleSizeChange = (pageSize: number) => {
      emit('update:size', { ...props.page, pageSize })
    }
    return {
      handleSelectionChange,
      handleCurrentChange,
      handleSizeChange
    }
  }
})
</script>

<style scoped lang="less">
</style>
```

> 当页码数据发生改变之后，就会去修改 page-content 中的 v-model 绑定的 ref 对象
>
> 当 page-content 中监听到 pageSize 和 pageCount 之后，那么就需要重新发送网络请求去请求数据
>
> 通过 watch 进行监听 pageSize 和 pageCount 数据
>
> 需要注意的是这里并不违背单项数据流
>
> 如果是直接对传入的数据进行修改的话，那么才违背单项数据流，但是这里是通过事件，传入最新的数据，并且通过 V-model 来双向绑定的数据，并不违背单项数据流的原则 v-model 不违背单项数据流原则

> 特别注意，v-model 是语法糖，基于绑定数据和绑定事件，所以这里虽然说子组件发出了事件，这里写了 
>
> v-model 就不需要写监听事件了，一样能接受到数据发生变化事件（qlTable 发出的事件）

`src\components\page-content\src\page-content.vue`

```vue
<template>
  <div class="page-content">
    <ql-table
      :listData="dataList"
      :listCount="dataCount"
      v-bind="contentTableConfig"
      v-model:page="pageInfo"
    >
    </ql-table>
  </div>
</template>

<script lang="ts">
import { defineComponent, computed, ref, watch } from 'vue'

// 使用包装类型后的 useStore 会有类型提示
import { useStore } from '@/store'

import QlTable from '@/base-ui/table'
export default defineComponent({
  components: {
    QlTable
  },
  props: {
    contentTableConfig: {
      type: Object,
      require: true
    },
    // 接收一个 pageName 属性
    pageName: {
      type: String,
      require: true
    }
  },
  setup(props) {
    const store = useStore()
    // 调用 system 中的 action 这样可以从外面规定传入的参数

    // 双向绑定 pageInfo
    const pageInfo = ref({ currentPage: 0, pageSize: 20 })

    // 监听 pageSize 和 pageCount 数据变化重新发送网络请求
    watch(pageInfo, () => {
      getPageData()
    })

    // 发送网络请求 默认是空对象，没有传入默认空对象
    const getPageData = (queryInfo: any = {}) => {
      store.dispatch('system/getPageListAction', {
        // pageUrl: '/users/list', // 请求路径
        pageName: props.pageName,
        queryInfo: {
          // 这里不能写死与 qlTable 中数据进行联动
          offset: pageInfo.value.currentPage * pageInfo.value.pageSize,
          size: pageInfo.value.pageSize,
          // offset: 0,
          // size: 10,
          ...queryInfo // 收集到的表单数据，带条件的查询，关键字模糊查询
        }
      })
    }
    getPageData()

    // 从 vuex 中获取数据

    // const userList = computed(() => store.state.system.userList)
    // const userCount = computed(() => store.state.system.userCount)
    // getter2   这样获取的就是data list  getters 里面返回的是一个函数，传入参数
    const dataList = computed(() => store.getters[`system/pageListData`](props.pageName))
    const dataCount = computed(() => store.getters[`system/pageListCount`](props.pageName))

    return {
      dataList,
      getPageData, // return 出去父组件用 组件ref.value.方法调用
      dataCount,
      pageInfo
    }
  }
})
</script>
```

