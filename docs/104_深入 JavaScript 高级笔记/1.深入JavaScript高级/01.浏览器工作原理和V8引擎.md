---
title: 浏览器工作原理和V8引擎
date: 2024-05-28 15:47:35
permalink: /pages/ee5c82/
categories:
  - 深入 JavaScript 高级笔记
tags:
  - coderwhy
  - 深入JavaScript高级
author:
  name: ZhangQiLong
  link: https://github.com/ZhangQiLong2023
---

## 浏览器的工作原理

### 浏览器如何运行 JavaScript 代码

高级语言需要先转化成机器指令再执行，这也是 JS 引擎帮助我们做的事

浏览器是如何运行 `JavaScript` 代码?

- 比如在网页上输入 `baidu.com` 域名会通过 `DNS` (专门做域名解析) 解析成对应的 `IP` 地址
- 所有的域名都会 `DNS` 解析成 `IP` 地址
- 当输入 `baidu.com` 按下回车的时候，解析成的 `IP` 地址找到对应的服务器地址，服务器返回 `index.html` 的网页，浏览器开始解析代码，解析的过程中会遇到 `CSS` 文件，则会去服务器里面下载对应的 `CSS` 文件(注意不是一次性下载完成，是遇到之后才回去下载)，遇到 `Script` 标签的时候，会从服务器里下载对应的 `js` 文件，里面包含 `JS` 相关代码，比如有个 `function` 则会运行 `function` 在浏览器中运行。

<center>

![浏览器如何运行JavaScript代码](/images/《深入JavaScript高级》笔记/01_浏览器工作原理和V8引擎/浏览器如何运行JavaScript代码.png)

</center>

比如遇到的 JS 代码下载下来之后，会被浏览器执行，那么 JS 是如何被浏览器执行的，这里就涉及到了浏览器的内核

### 浏览器从下载再到渲染的过程

首先下载到 `HTML` 文件，如果这时候有 `JavaScript` 对 `DOM` 进行操作的话，`JavaScript` 结合 `HTML` 共同构建 `DOM Tree` 然后下载 `CSS` 文件通过 `CSS匹配规则` 共同构建出 `Render Tree` 之后会有 `Layout` 适应到不同的屏幕上，`Render Tree` 会先生成再由 `Layout Tree` 在其基础上进行修改

<center>

![webkit内核工作流程图](/images/《深入JavaScript高级》笔记/01_浏览器工作原理和V8引擎/webkit内核工作流程图.png)

</center>

<center>

![浏览器从下载再到渲染的过程](/images/《深入JavaScript高级》笔记/01_浏览器工作原理和V8引擎/浏览器从下载再到渲染的过程.png)

</center>

### 浏览器渲染引擎(浏览器内核)

浏览器渲染引擎是由各大浏览器厂商依照 `W3C` 标准自行研发的，一般习惯将之称为「浏览器内核」，主要功能是解析 `HTML/CSS` 进行渲染页面，渲染引擎决定了浏览器如何显示网页的内容以及页面的格式信息。

不同的浏览器有不同的内核组成：

- Gecko：早期被 `Netscape` 和 `Mozilla Firefox` 浏览器浏览器使用
- Trident：微软开发，被 `IE4 - IE11` 浏览器使用，但是 `Edge` 浏览器已经转向 `Blink`
- Webkit：苹果基于 `KHTML` 开发、开源的，用于 `Safari` `Google Chrome` 之前也在使用
- Blink：是 `Webkit` 的一个分支，`Google` 开发，目前应用于 `Google Chrome` `Edge` `Opera`等

### JavaScript 引擎

`JavaScript` 引擎帮助我们将 `JavaScript` 代码翻译成 `CPU` 指令来执行。

为什么需要 `JavaScript` 引擎呢？

- 高级的编程语言都需要转成最终的机器指令来执行，编写的 `JavaScript` 无论是交给浏览器或者是 `Node` 最终都需要交给 `CPU` 来执行，但是 `CPU` 只认识自己的指令集，所以只有机器语言最终才能被 `CPU` 执行，而 `JavaScript` 引擎完成了将 `JavaScript` 代码翻译成 `CPU` 认识的指令集的过程

比较常见的 `JavaScript` 引擎有：

- SpiderMonkey：第一款 `JavaScript` 引擎，由 `Brendan Eich` 开发( `JavaScript` 作者)
- Chakra：微软开发，用于 `IE` 浏览器
- JavaScriptCore：`WebKit` 中的 `JavaScript` 引擎，`Apple` 公司开发
- V8：`Google` 开发的强大 `JavaScript` 引擎，也帮助 `Chrome` 从众多浏览器中脱颖而出

### 渲染引擎的工作流程

浏览器渲染引擎最重要的工作就是将 ` HTML` 和 ` CSS` 文档解析组合最终渲染到浏览器窗口上。渲染引擎在接收到` HTML` 文件后主要进行了以下操作：`解析 HTML 构建 DOM 树 -> 构建渲染树 -> 渲染树布局 -> 渲染树绘制`

解析 `HTML` 构建 `DOM` 树时渲染引擎会将 `HTML` 文件的便签元素解析成多个 `DOM` 元素对象节点，并将这些节点根据父子关系组成一个树结构。同时 `CSS` 文件被解析成 `CSS` 规则表，然后将每条 `CSS` 规则按照「从右向左」的方式在 `DOM` 树上进行逆向匹配，生成一个具有样式规则描述的 `DOM` 渲染树。接下来将渲染树进行布局、绘制的过程。首先根据 `DOM` 渲染树上的样式规则，对 `DOM` 元素进行大小和位置的定位，关键属性如 `position` `width` `margin` `padding` `top` `border` 再根据元素样式规则中的 `color` `background` `shadow` 规则进行绘制

另外，这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的 `html` 都解析完成之后再去构建和布局 `render` 树。它是解析完一部分内容就显示一部分内容，同时，可能还在通过网络下载其余内容。

在浏览器渲染完首屏页面后，如果对 `DOM` 进行操作会引起浏览器引擎对 `DOM` 渲染树的重新布局和重新绘制，叫做「重排」和「重绘」，由于重排和重绘是前后依赖的关系，重绘发生时未必会触发渲染引擎的重排，但如果发生了重排就必然会触发重绘操作，这样带来的性能损害就是巨大的。因此我们在做性能优化的时候应该遵循「避免重排减少重绘」的原则

### 关于 CSS 规则的匹配

上面提到过 `CSS` 规则是按照「从右向左」的方式在 `DOM` 树上进行逆向匹配的，最终生成一个具有样式规则描述的 `DOM` 渲染树。但是为什么要「从右向左」做逆向匹配呢？重新回看【webkit 内核工作流程图】

<center>

![webkit 内核工作流程图](/images/《深入JavaScript高级》笔记/01_浏览器工作原理和V8引擎/webkit内核工作流程图.png)

</center>

`CSS` 规则匹配是发生在 `webkit` 引擎的「Attachment」过程中，浏览器要为每一个 `DOM Tree` 中的元素扩充 `CSS` 样式规则（匹配 Style Rules）。对于每个 `DOM` 元素须在所有 `Style Rules` 中找到符合的 `selector` 并将对应的规则进行合并。选择器的「解析」实际是在这里执行的，在遍历 `DOM Tree` 时，从 `Style Rules` 中去寻找对应的 `selector`

举一个最简单的栗子：

```vue
<template>
  <div>
    <div class="t">
      <span>test</span>
      <p>test</p>
    <div>
  </div>
</template>

<style>
  div{ color: #000; }
  div .t span{ color: red; }
  div .t p{color: blue; }
</style>
```

此处有一个`html`元素和一个`style`元素，两者需要做遍历匹配

<center>

![浏览器工作原理和V8引擎有一个html元素和一个style元素，两者需要做遍历匹配](/images/《深入JavaScript高级》笔记/01_浏览器工作原理和V8引擎/有一个html元素和一个style元素，两者需要做遍历匹配.png)

</center>

此处会有 `4*3` 个匹配项，如果做正向匹配，在遇到 `<span>` 标签匹配 `div .t p{ color: red;}` 到匹配项时，计算机首先要找到 `<span>` `div .t` 的规则，然后再匹配 `<span>` 是否为 `p` 标签，此处匹配不成功，产生了三次浪费，如果是逆向匹配，那么第一次从子元素对比 `<span>` 是否为 `p` 标签便可排除此规则，效率更高

如果将 `HTML` 结构变复杂，`CSS` 规则表变庞大，那么「逆向匹配」的优势就远大于「正向匹配」了，因为匹配的情况远远低于不匹配的情况。另外，如果在选择器结尾加上通配符 `*` 那么「逆向匹配」的优势就大打折扣了，这也就是很多优化原则提到的「尽量避免在选择器末尾添加通配符」的原因。

极限了想，如果我们的样式表不存在嵌套关系，如下：

```vue
<template>
  <div class="t">
    <span class="div_t_span">test</span>
    <p class="div_t_p">test</p>
  <div>
</template>

<style>
div{ color: #000; }
.div_t_span{ color: red; }
.div_t_p{color: blue; }
</style>
```

那么引擎的「Attachment」过程将得到极大的精简，效率也是可想而知的，这就是为什么「微信小程序」样式表不建议使用关系行写法的原因。相关的性能优化如下：

- 减少 `JS` 加载对 `DOM` 渲染的影响

将 `JS` 文件放在 `HTML` 文档后加载，或者使用异步的方式加载 `JS` 代码

- 避免重排减少重绘

在做 `CSS` 动画的时候减少使用 `width` `margin` `padding` 等影响 `CSS` 布局对规则，可以使用 `CSS3` 的 `transform` 代替。另外值得注意的是，在加载大量的图片元素时，尽量预先限定图片的尺寸大小，否则在图片加载过程中会更新图片的排版信息，产生大量的重排。

- 减少使用关系型样式表的写法

直接使用唯一的类名即可最大限度的提升渲染效率，另外尽量避免在选择器末尾添加通配符

- 减少 DOM 的层级

减少无意义的 `DOM` 层级可以减少渲染引擎 `Attachment` 过程中的匹配计算量

## V8 引擎工作原理

### 什么是 V8?

V8 是一个由 `Google` 开发的开源 `JavaScript` 引擎，目前用在 `Chrome` 浏览器和 `Node.js` 中，其核心功能是执行易于人类理解的 `JavaScript` 代码

<center>

![image.png](/images/《深入JavaScript高级》笔记/01_浏览器工作原理和V8引擎/V8执行JavaScript.png)

</center>

那么 `V8` 又是怎么执行 `JavaScript` 代码的呢？

其主要核心流程分为编译和执行两步。首先需要将 `JavaScript` 代码转换为低级中间代码或者机器能够理解的机器代码，然后再执行转换后的代码并输出执行结果

<center>

![image.png](/images/《深入JavaScript高级》笔记/01_浏览器工作原理和V8引擎/转换为中间代码.png)

</center>

可以把 `V8` 看成是一个虚构出来的计算机，也称为虚拟机，虚拟机通过模拟实际计算机的各种功能来实现代码的执行，如模拟实际计算机的 `CPU` `堆栈` `寄存器` 等，虚拟机还具有 它自己的一套指令系统。

所以对于 `JavaScript` 代码来说 `V8` 就是它的整个世界，当 `V8` 执行 `JavaScript` 代码时， 并不需要担心现实中不同操作系统的差异，也不需要担心不同体系结构计算机的差异，只需要按照虚拟机的规范写好代码就可以了

### 高级代码为什么需要先编译再执行？

先从 `CPU` 是怎么执行机器代码讲起，你可以把 `CPU` 看成是一个非常小的运算机器， 我们可以通过二进制的指令和 `CPU` 进行沟通，比如我们给 `CPU` 发出 `1000100111011000` 的二进制指令，这条指令的意思是将一个寄存器中的数据移动 到另外一个寄存器中，当处理器执行到这条指令的时候，便会按照指令的意思去实现相关的操作。

为了能够完成复杂的任务，工程师们为 `CPU` 提供了一大堆指令，来实现各种功能就把这一大堆指令称为指令集，也就是机器语言。

注意，`CPU` 只能识别二进制的指令，但是对程序员来说，二进制代码难以阅读和记忆，于是我们又将二进制指令集转换为人类可以识别和记忆的符号，这就是汇编指令集，可以参考下面的代码：

```javascript
1000100111011000  // 机器指令
mov ax,bx         // 汇编指令
```

但是`CPU`并不能直接识别汇编语言，所以如果你使用汇编编写了一段程序，你还需要一个汇编编译器，其作用

是将汇编代码编程成机器代码，具体流程可以参考下图：

<center>

![image.png](/images/《深入JavaScript高级》笔记/01_浏览器工作原理和V8引擎/解释执行流程图.png)

</center>

虽然汇编语言对机器语言做了一层抽象，减少了程序员理解机器语言的复杂度，但是汇编语 言依然是复杂且繁琐的，即便你写一个非常简单的功能，也需要实现大量的汇编代码，这主要表现在以下两点

首先，不同的 `CPU` 有着不同的指令集，如果要使用机器语言或者汇编语言来实现一个功能，那么你需要为每种架构的 `CPU` 编写特定的汇编代码，这会带来巨大的、枯燥繁琐的操作，你可以参看下图：

<center>

![image.png](/images/《深入JavaScript高级》笔记/01_浏览器工作原理和V8引擎/需要为每种架构的cpu编写特定的汇编代码.png)

</center>

其次，在编写汇编代码时，还需要了解和处理器架构相关的硬件知识，比如需要使用 寄存器、内存、操作 `CPU` 等。大部分程序员在编写应用的时候，只想专心处理业务逻辑， 并不想要过多理会这些处理器架构相关的细节。

因此我们需要一种屏蔽了计算机架构细节的语言，能适应多种不同 `CPU` 架构的语言，能专心处理业务逻辑的语言，诸如 `C` `C++` `Java` `C#` `Python` `JavaScript` 等，这些高级语言就应运而生了。

和汇编语言一样，处理器也不能直接识别由高级语言所编写的代码，那怎么办？通常有两种方式来执行这些代码。

第一种是解释执行，需要先将输入的源代码通过解析器编译成中间代码，之后直接使用解释器解释执行中间代码，然后直接输出结果。具体流程如下图所示：

<center>

![image.png](/images/《深入JavaScript高级》笔记/01_浏览器工作原理和V8引擎/解释执行流程图.png)

</center>

第二种是编译执行。采用这种方式时，也需要先将源代码转换为中间代码，然后我们的编译 器再将中间代码编译成机器代码。通常编译成的机器代码是以二进制文件形式存储的，需要 执行这段程序的时候直接执行二进制文件就可以了。还可以使用虚拟机将编译后的机器代码保存在内存中，然后直接执行内存中的二进制代码。

<center>

![image.png](/images/《深入JavaScript高级》笔记/01_浏览器工作原理和V8引擎/编译执行流程图.png)

</center>

以上就是计算机执行高级语言的两种基本的方式：解释执行和编译执行。但是针对不同的高级语言，这个实现方式还是有很大差异的，比如要执行 `C` 语言编写的代码，你需要将其编译为二进制代码的文件，然后再直接执行二进制代码。而对于像 `Java` `JavaScript` 等，则需要不同虚拟机，模拟计算机的这个编译执行流程。执行 `Java` 语言，需要经过 `Java` 虚拟机的转换，执行 `JavaScript` 需要经过 `JavaScript` 虚拟机的转换。

即便是 `JavaScript` 一门语言，也有好几种流行的虚拟机，它们之间的实现方式也存在着一部分差异，比如苹果公司在 `Safari` 中就是用 `JavaScriptCore` 虚拟机，`Firefox` 使用了 `TraceMonkey` 虚拟机，而 `Chrome` 则使用了 `V8` 虚拟机

### V8 是怎么执行 JavaScript 代码的？

那么 `V8` 作为 `JavaScript` 的虚拟机的一种，它到底是怎么执行 `JavaScript` 代码的呢？是解释执行，还是编译执行呢？

实际上 `V8` 并没有采用某种单一的技术，而是混合编译执行和解释执行这两种手段，我们把这种混合使用编译器和解释器的技术称为 `JIT(Just In Time)` 技术。

这是一种权衡策略，因为这两种方法都各自有自的优缺点，解释执行的启动速度快，但是执行时的速度慢，而编译执行的启动速度慢，但是执行时的速度快。你可以参看下面完整的 `V8` 执行 `JavaScript` 的流程图：

<center>

![image.png](/images/《深入JavaScript高级》笔记/01_浏览器工作原理和V8引擎/V8执行一段JavaScript流程图.png)

</center>

我们先看上图中的最左边的部分，在 `V8` 启动执行 `JavaScript` 之前，它还需要准备执行 `JavaScript` 时所需要的一些基础环境，这些基础环境包括了“堆空间” “栈空间” “全局执行上下文” “全局作用域” “消息循环系统” “内置函数”等，这些内容都是在执行 `JavaScript` 过程中需要使用到的，比如：

`JavaScript` 全局执行上下文就包含了执行过程中的全局信息，比如一些内置函数，全局变量等信息

全局作用域包含了一些全局变量，在执行过程中的数据都需要存放在内存中； 而`V8`是采用了经典的堆和栈的管理内存管理模式，所以`V8`还需要初始化了内存中的堆和栈结构；

另外，要我们的 `V8` 系统活起来，还需要初始化消息循环系统，消息循环系统包含了消息驱动器和消息队列，它如同 `V8` 的心脏，不断接受消息并决策如何处理消息。

基础环境准备好之后，接下来就可以向 `V8` 提交要执行的 `JavaScript` 代码了。 首先 `V8` 会接收到需要执行的 `JavaScript` 源代码，不过这对 `V8` 来说只是一堆字符串，`V8` 并不能直接理解这段字符串的含义，它需要结构化这段字符串。结构化是指信息经过分析后可分解成多个互相关联的组成部分，各组成部分间有明确的层次结构，方便使用和维护，并有一定的操作规范。

`V8` 源代码的结构化之后，就生成了抽象语法树 (AST)，我们称为 `AST` ，`AST` 是便于 `V8` 理解的结构。这里还需要注意一点，在生成 `AST` 的同时，`V8` 还会生成相关的作用域，作用域中存放相关变量

有了 `AST` 和作用域之后，接下来就可以生成字节码了，字节码是介于 `AST` 和机器代码的中间代码。但是与特定类型的机器代码无关，解释器可以直接解释执行字节码，或者通过编译器将其编译为二进制的机器代码再执行。

好了，生成了字节码之后，解释器就登场了，它会按照顺序解释执行字节码，并输出执行结果。

相信你注意到了，在解释器附近有一个监控机器人，这是一个监控解释器执行状态的模块，在解释执行字节码的过程中，如果发现了某一段代码会被重复多次执行，那么监控机器人就会将这段代码标记为热点代码。

当某段代码被标记为热点代码后，`V8` 就会将这段字节码丢给优化编译器，优化编译器会在后台将字节码编译为二进制代码，然后再对编译后的二进制代码执行优化操作，优化后的二进制机器代码的执行效率会得到大幅提升。如果下面再执行到这段代码时，那么 `V8` 会优先选择优化之后的二进制代码，这样代码的执行速度就会大幅提升。

不过，和静态语言不同的是，`JavaScript` 是一种非常灵活的动态语言，对象的结构和属性是可以在运行时任意修改的，而经过优化编译器优化过的代码只能针对某种固定的结构，一旦在执行过程中，对象的结构被动态修改了，那么优化之后的代码势必会变成无效的代码，这时候优化编译器就需要执行反优化操作，经过反优化的代码，下次执行时就会回退到解释器解释执行

```javascript
function sum(a, b) {
  return a + b
}

sum(10, 20)
sum(20, 30)
sum(30, 40)
sum(40, 50)
sum(50, 60)
sum("aaa", "bbb")
```

比如上图中前五次执行的时候都是采用优化后的代码，但是第六次执行的时候，由于数据类型发生了转变，所以优化后的代码就变成了无效代码，这时候就会执行反优化操作，重新交给解释器执行代码

### 解析器（Parser）如何把源码转换成 AST？

要让 `V8` 执行我们编写的源码，就要将源码转换成 `V8` 能理解的格式。`V8` 先把源码解析为抽象语法树 `AST`，这是用来表示源码的树形结构的对象，这个过程称为解析 `(Parsing)`，主要由 `V8` 的 `Parser` 模块实现。然后，`V8` 的解释器会把 `AST` 编译为字节码，一边解释一边执行。解析和编译过程的性能非常重要，因为 `V8` 只有等编译完成后才能运行代码。整个解析过程可分为两部分：

- 词法分析：将字符流转换为 `tokens`，字符流就是我们编写的一行行代码，`token` 是指语法上不能再分割的最小单位，可能是单个字符，也可能是字符串，图中的 `Scanner` 就是 `V8` 的词法分析器

- 语法分析：根据语法规则，将 `tokens` 组成一个有嵌套层级的抽象语法结构树，这个树就是 `AST`，在此过程中，如果源码不符合语法规范，解析过程就会终止，并抛出语法错误。图中的 `Parser`和`Pre-Parser`都是`V8` 的语法分析器。

### 词法分析

在 `V8` 中，`Scanner` 负责接收 `Unicode` 字符流，并将其解析为 `tokens`，提供给解析器使用。比如 `var a = 1;` 这行代码，经过词法分析后的 `tokens` 就是下面这样：

```json
[
  {
    "type": "Keyword",
    "value": "var"
  },
  {
    "type": "Identifier",
    "value": "a"
  },
  {
    "type": "Punctuator",
    "value": "="
  },
  {
    "type": "Numeric",
    "value": "1"
  },
  {
    "type": "Punctuator",
    "value": ";"
  }
]
```

可以看到 `var a = 1;` 这样一行代码包括 5 个 `tokens` `关键字var` `标识符name` `赋值运算符=` `分割符;`

### 语法分析

接下来， `V8` 的解析器会通过语法分析，根据 `tokens` 生成 `AST` `var a = 1;` 这行代码生成的 `AST` 的 `JSON` 结构如下所示：

```json
{
  "type": "Program",
  "start": 0,
  "end": 10,
  "body": [
    {
      "type": "VariableDeclaration",
      "start": 0,
      "end": 10,
      "declarations": [
        {
          "type": "VariableDeclarator",
          "start": 4,
          "end": 9,
          "id": {
            "type": "Identifier",
            "start": 4,
            "end": 5,
            "name": "a"
          },
          "init": {
            "type": "Literal",
            "start": 8,
            "end": 9,
            "value": 1,
            "raw": "1"
          }
        }
      ],
      "kind": "var"
    }
  ],
  "sourceType": "module"
}
```

但对于一份 `JavaScript` 源码，如果所有源码在执行前都要完全经过解析才能执行，那必然会面临以下问题。

- 代码执行时间变长：一次性解析所有代码，必然会增加代码的运行时间。
- 消耗更多内存：解析完的 `AST` 以及根据 `AST` 编译后的字节码都会存放在内存中，会占用更多内存空间。
- 占用磁盘空间：编译后的代码会缓存在磁盘上，占用磁盘空间。

所以，现在主流 `JavaScript` 引擎都实现了「延迟解析」

### 延迟解析 Lazy Parsing

延迟解析的思想很简单：在解析过程中，对于不是立即执行的函数，只进行预解析(Pre Parser)，只有当函数调用时，才对函数进行全量解析。

进行预解析时，只验证函数语法是否有效、解析函数声明、确定函数作用域，不生成 `AST` ，而实现预解析的，就是 `Pre-Parser` 解析器

```javascript
function foo(a, b) {
  var res = a + b
  return res
}

var a = 1
var c = 2
foo(1, 2)
```

由于 `Scanner` 是按字节流从上往下一行行读取代码的，所以 `V8` 解析器也是从上往下解析代码。当 `V8` 解析器遇到函数声明 `foo` 时，发现它不是立即执行，所以会用 `Pre-Parser` 解析器对其预解析，过程中只会解析函数声明，不会解析函数内部代码，不会为函数内部代码生成 `AST` 。

然后 `Ignition` 解释器会把 `AST` 编译为字节码并执行，解释器会按照自上而下的顺序执行代码，先执行 `var a = 1;` 和 `var a = 2;` 两个赋值表达式，然后执行函数调用 `foo(1,2)` 这时 `Parser` 解析器才会继续解析函数内的代码、生成 `AST`，再交给 `Ignition` 解释器编译执行。

再比如如下代码，当下面进行解析的时候，由于 `inner` 函数没有被调用，所以只会对 `inner` 函数进行预解析，所以 `inner` 函数里面的内容并没有进行预解析操作

```javascript
function outer(){
  function inner(){
    var inner = "inner"
    console.log(inner)
}

outer()
```

### 跟踪一段实际代码的执行流程

我们以一段最简单的 `JavaScript` 代码为例，如果将这段非常简单的代码提交给 `V8` 引擎，`V8` 在处理过程中，中间所产生的结果是怎样的呢？下面我们就一步一步详细 “追踪” 下

```javascript
var test = "GeekTime"
```

我们知道，首先这段代码会被解析器结构化称 `AST`，下面我们就来看看第一阶段生成的 `AST` 是什么样子的？

要查看 `V8` 中间生成的一些结构，可以使用 `V8` 提供的调试工具 `D8` 来查看，将上面代码保存到 `test.js` 的文件中，然后执行下面命令：

```javascript
d8 --print-ast test.js
```

执行这段命令之后，`D8` 会打印出如下内容：

<center>

![image.png](/images/《深入JavaScript高级》笔记/01_浏览器工作原理和V8引擎/跟踪一段实际代码的执行流程1.png)

</center>

上面这个结构就是 `AST`，它就是 `JS` 源代码的结构化表述，`AST` 是个树状结构，直观地理解，你可以将其转换为一个图形树，如下图所示：

<center>

![image.png](/images/《深入JavaScript高级》笔记/01_浏览器工作原理和V8引擎/跟踪一段实际代码的执行流程2.png)

</center>

从图中可以看出，`AST` 和代码结构也是一一对应关系，并且后续所有的操作都会直接或者间接基于它。

上面我们还提到了，在生成 `AST` 的同时，还会生成作用域，同样我们使用 `D8` 来看看它生成的作用域是什么样子，你可以使用下面的命令来查看作用域：

```javascript
d8 --print-scopes test.js
```

执行这段命令之后，`D8` 会打印出如下内容：

<center>

![image.png](/images/《深入JavaScript高级》笔记/01_浏览器工作原理和V8引擎/跟踪一段实际代码的执行流程3.png)

</center>

上面这行代码生成了一个全局作用域，我们可以看到 `test` 变量被添加进了这个全局作用域中。

生成了`AST`和作用域之后，就可以使用解释器生成字节码了，同样你可以使用 `D8` 来打印生成后的字节码，打印的命令如下所示：

```javascript
d8 --print-bytecode test.js
```

执行这段语句，最终打印出来的结果如下所示：

<center>

![image.png](/images/《深入JavaScript高级》笔记/01_浏览器工作原理和V8引擎/跟踪一段实际代码的执行流程4.png)

</center>

当然也可以通过 [https://astexplorer.net/](https://astexplorer.net/) 网址来查看 `AST` 抽象语法树

<center>

![image.png](/images/《深入JavaScript高级》笔记/01_浏览器工作原理和V8引擎/跟踪一段实际代码的执行流程5.png)

</center>

## V8 额外补充

<center>

![image.png](/images/《深入JavaScript高级》笔记/01_浏览器工作原理和V8引擎/JavaScript源代码被V8处理为机器码流程.png)

</center>

为什么不先转换成机器码呢，为什么先转化成字节码呢？

因为代码跑在什么样的环境是不确定的，所以 `CPU` 不一样，`CPU` 的架构是不一样的，架构不一样第四步 `Ignition` 就不确定转化成哪种机器码了，所以先转化成字节码。等到代码再执行的时候，再把字节码转成对应平台的机器码，这样比直接通过 AST 转化成机器码的效率要高，「字节码是跨平台的」

### JavaScript 的执行过程

```javascript
/**
 * 预解析
 * 1. 代码被解析，V8引擎内部会帮助我们创建一个对象
 */
var globalObject = {
  String: "类",
  Date: "类",
  setTimeout: "函数",
  window: globalObject,
}
```

```javascript
var name = "zhangqilong"

var num1 = 20
var num2 = 30
var result = num1 + num2
```

```javascript
/**
 * 运行代码
 * 2. V8为了执行代码，V8引擎内部会有一个执行上下文栈(函数调用栈)
 */
var globalObject = {
  String: "类",
  Date: "类",
  setTimeout: "函数",
  window: globalObject,
  name: undefined,
  num1: undefined,
  num2: undefined,
  result: undefined,
}
```

这里在 `result` 定义之前进行打印操作，结果为 `undefined` 而并非是未定义，原因就是在执行代码之前首先对代码进行了预解析操作，所以在执行之前全局对象中就有了 `result:undefined`

```javascript
var name = "zhangqilong"

console.log(result) // undefined

var num1 = 20
var num2 = 30
var result = num1 + num2
```
