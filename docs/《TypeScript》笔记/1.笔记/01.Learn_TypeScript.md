---
title: Learn_TypeScript
date: 2022-01-29 22:50:43
permalink: /pages/2c781f/
categories:
  - 《TypeScript》笔记
tags:
  - typescript
author:
  name: ZhangQiLong
  link: https://github.com/ZhangQiLong2023
---

# Learn_TypeScript_Note

## 一、类型带来的问题

### 1. 类型错误

```js
// 当前 foo 函数，再被其他地方调用时，没有做任何的参数校验
// 1> 没有对类型进行校验
// 2> 没有对是否传入参数进行校验
function foo(message) {
  console.log(message.length)
}
foo("Hello TypeScript") // 16
foo("Hello ZhangQiLong") // 12

// 但是如果执行下面的代码就会报错
foo() // TypeError: Cannot read property 'length' of undefined

// 如果下面还会有代码逻辑的时候，整个程序后面代码都会被这行报错的代码终止掉
```

![image-20230114190543336](http://www.zhangqilong.cn/img/qlBlog_images/TypeScript/Learn_TypeScript/image-20230114190543336.png)

### 2. 类型思维的缺失

![image-20230114190811777](http://www.zhangqilong.cn/img/qlBlog_images/TypeScript/Learn_TypeScript/image-20230114190811777.png)

## 二、TypeScript 的编译环境

在前面提到过，TypeScript 最终会被编译成 JavaScript 来运行，所以我们需要搭建对应的环境

![image-20230114200519207](http://www.zhangqilong.cn/img/qlBlog_images/TypeScript/Learn_TypeScript/image-20230114200519207.png)

```js
npm install typescript -g   // 全局安装 typescript
tsc --version   // 查看安装的 tsc 版本
tsc typescript.ts  // 就可以将 ts 代码转成 js 代码
```

## 三、TypeScript 初体验

### 1. Tsc

```ts
// 01_Hello_TypeScript.ts
1. 变量赋值
let message:string = "ZhangQiLong"

message = 123   // Error:不能将类型“number”分配给类型“string”。

2. 函数传参
function foo(payload:string){
	console.log(payload);
}

foo(123)  // Error: 类型“number”的参数不能赋给类型“string”的参数。
foo()     // Error: 01_Hello_TypeScript.ts(3, 14): 未提供 "payload" 的自变量。
```

但是上述编写的 `typescript` 代码不能运行在浏览器中，所以我们需要先将其编译成 `typescript` 代码

```js
tsc 01_Hello_TypeScript.ts
// 执行上述代码，会在同目录文件夹下产生一个相同名字的 js 文件，并且 js 文件中变量命名是 var
```

如果上述代码在被类型限制之后，依然编写 `foo(123)` 这种错误代码，就会在编译阶段就会报错 `Argument of type 'number' is not assignable to parameter of type 'string'. foo(123);`，不需要等到运行期间就会报错。

### 2. TypeScript 的数据类型

```ts
const name: string = "abc"
const age: number = 18

console.log(name)
console.log(age)

// 默认情况下，ts文件都是在同一环境下编译的，如果在其他文件下，上面的 name 或者 age 被定义了
// 或者在浏览器整个 DOM 环境下有 name 的话，这里就会报错
// export {} 就表示这个文件就是一个模块，意味着这个 ts 文件有自己单独的作用域了
export {}
```

#### 2.1 Ts 代码自动编译成 JS 文件

1.  第一种方案：使用 `webpack` 搭建环境，就可以将 `ts` 代码自动转化成 `js` 代码，并且运行在浏览器中

    1. 首先创建 `03_webpack_ts\src` 的目录结构，编写 `ts` 代码需要放在 `src` 文件夹下面
    2. `cd 03_webpack_ts`
    3. `npm init` 创建一个 `package.json` 文件
    4. `npm install webpack webpack-cli -D` 从 `webpack4` 开始安装 `webpack` `webpack-cli` 也需要安装
    5. 在 `03_webpack_ts` 文件夹下创建 `webpack.config.ts` 文件

    ```ts
    const path = require("path");

    module.exports = {
    // 配置入口
    entry: "./src/main.ts",
    // 配置出口
    output: {
    path: path.resolve(\_\_dirname, "./dist"),
    filename: "bundle.js",
    },
    };

    ```

    6. 配置初始化好的 `package.json` 文件

    ```js
    {
      "name": "03_webpack_ts",
      "version": "1.0.0",
      "description": "",
      "main": "index.js",
      "scripts": {
        "test": "echo \"Error: no test specified\" && exit 1",
         // 配置 build 运行 webpack，打包的时候就会执行 webpack.config.ts 配置文件
        "build":"webpack"
      },
      "author": "",
      "license": "ISC",
      "devDependencies": {
        "webpack": "^5.75.0",
        "webpack-cli": "^5.0.1"
      }
    }
    ```

    7. 编写 `math.ts` 代码

    ```ts
    // 03_webpack_ts\src\math.ts
    export function sum(num1: number, num2: number) {
      return num1 + num2
    }
    ```

    8. 编写 `main.ts` 代码引入 `math.ts`

    ```ts
    import { sum } from "./math"

    console.log(sum(20, 30))
    ```

    9. `npm install ts-loader typescript -D` 这里需要安装 `ts-loader` 和 `typescript` ，`ts-loader` 就会直接利用 `typescript` 对代码进行编译，由于刚才 `typescript` 是全局安装的所以这里也需要本地安装
    10. 配置 `webpack.config.ts` 文件

    ```js
    const path = require("path")

    module.exports = {
      // 配置入口
      entry: "./src/main.ts",
      // 配置出口
      output: {
        path: path.resolve(__dirname, "./dist"),
        filename: "bundle.js",
      },
      resolve: {
        // 意味着到时候找某个文件的时候会加上后缀名 .ts 在 math.ts 中 import { sum } from "./math";
        extensions: [".ts"],
      },
      module: {
        rules: [
          {
            // 匹配到以 .ts 结尾的文件
            test: /\.ts$/,
            // 就使用 ts-loader
            loader: "ts-loader",
          },
        ],
      },
    }
    ```

    11. 使用 `tsc --init` 生成 `tsconfig.json` 在执行之前需要先生成 `tsconfig.json` 否则会报错
    12. 执行 `npm run build` 就会在 `03_webpack_ts\dist` 文件夹下生成 `bundle.js` 文件
    13. 但是如果我们每次编写完代码都需要执行 `npm run build` 就会特别麻烦，所以安装 `npm install webpack-dev-server -D` 搭建一个本地服务
    14. 然后再次更改 `package.json` 文件

    ```js
    {
      "name": "03_webpack_ts",
      "version": "1.0.0",
      "description": "",
      "main": "index.js",
      "scripts": {
        "test": "echo \"Error: no test specified\" && exit 1",
        "build": "webpack",
        "serve": "webpack serve"
      },
      "author": "",
      "license": "ISC",
      "devDependencies": {
        "ts-loader": "^9.4.2",
        "typescript": "^4.9.4",
        "webpack": "^5.75.0",
        "webpack-cli": "^5.0.1"
      },
      "dependencies": {
        "@swc/register": "^0.1.10"
      }
    }
    ```

    15. `"serve": "webpack serve"` 意味着，开启本地服务的话，执行 `webpack serve`
    16. 另外还需要说明需要用到的模板是 `03_webpack_ts\index.html`
    17. 需要安装 `npm install html-webpack-plugin -D`
    18. 配置 `webpack.config.ts` 文件

    ```js
    const path = require("path")
    const HtmlWebpackPlugin = require("html-webpack-plugin")
    module.exports = {
      mode: "development",
      // 配置入口
      entry: "./src/main.ts",
      // 配置出口
      output: {
        path: path.resolve(__dirname, "./dist"),
        filename: "bundle.js",
      },
      devServer: {},
      resolve: {
        // 意味着到时候找某个文件的时候会加上后缀名 .ts .js 在 math.ts 中 import { sum } from "./math";
        extensions: [".ts", ".js", ".cjs", ".json"],
      },
      module: {
        rules: [
          {
            // 匹配到以 .ts 结尾的文件
            test: /\.ts$/,
            // 就使用 ts-loader
            loader: "ts-loader",
          },
        ],
      },
      //2. 使用模板
      plugins: [
        new HtmlWebpackPlugin({
          // 将 index.html 作为模板
          template: "./index.html",
        }),
      ],
    }
    ```

    19. 执行 `npm run serve` 即可

2.  第二种方案：安装 -> `ts-node` 库 执行 `ts-node TypeScript.ts` 就可以直接运行 `ts` 代码

```js
npm install ts-node -g   // 全局安装 ts-node

// 并且安装 ts-node 依赖的两个包
npm install tslib @types/node -g
```

```ts
ts-node .\02_TypeScript的数据类型.ts  //执行 02_TypeScript的数据类型.ts 代码
abc
18
// 可以直接在node环境中打印运行结果
```

#### 2.2 变量的定义

1. var/let/const

```ts
var name: string = "ZhangQiLong" // 不推荐使用 var
let age: number = 18
let height: number = 1.8
export {}
```

2. string 和 String 的区别

```ts
// string: TypeScript中的字符串类型
// String:JavaScript的字符串包装类的类型
const message: string = "Hello World"
```

3. tslint

```ts
// eslint ->js代码规范
// tslint ->ts代码规范
npm install tslint -g
tslint --init       // 生成配置文件
```

4. 类型推导

```ts
// 默认情况下进行赋值时，会将赋值的值的类型，作为前面标识符的类型这个过程称之为类型推断

// foo 没有添加类型注释
let foo = "ZhangQiLong"
foo = 123 // Error:不能将类型“number”分配给类型“string”。
```

## 四、JavaScript 和 TypeScript 的数据类型

### 1. TypeScript 是 JavaScript 的一个超级

![image-20230115111538315](http://www.zhangqilong.cn/img/qlBlog_images/TypeScript/Learn_TypeScript/image-20230115111538315.png)

### 2.number

```ts
// 04_变量的定义\02_number类型的使用.ts
let num: number = 123

num = 222

let num1: number = 100 // 十进制
let num2: number = 0b111 // 二进制
let num3: number = 0o456 // 八进制
let num4: number = 0x123 // 十六进制

console.log(num1, num2, num3, num4)

// ts-node .\02_number类型的使用.ts
// 100 7 302 291
```

### 3.Boolean

```ts
// 04_变量的定义\03_Boolean类型的使用.ts
let flag: boolean = true //这里接收的是布尔值，不是布尔值对象(let b:boolean = new Boolean())
flag = 20 > 30
console.log(flag)

// ts-node .\03_Boolean类型的使用.ts
// false
```

### 4.String

```ts
let message = "ZhangQiLong" // 双引号
let message1 = "ZhangQiLong" // 单引号

const name = "ZhangQiLong"
const age = 18
const height = 1.8

// 可以使用ES6中的模板字符串
let message2 = `name:${name} age:${age} height:${height}`

console.log(message, message1, message2) // ZhangQiLong ZhangQiLong name:ZhangQiLong age:18 height:1.8

export {}
```

### 5.array

```ts
// 确定一个事实：names是一个数组类型，但是数组中存放的是什么类型的元素呢？
// 不好的习惯：一个数组中在 TypeScript 开发中，最好存放的数据类型是固定的
const names = []

//1. 在数组中存放不同的类型是不好的习惯
// names.push("abc");
// names.push(123);

// 类型注解：type annotation
//1. 添加类型注解的第一种方式
const names1: Array<string> = [] // 不推荐(react jsx中是有冲突的 <div></div>)
//2. 添加类型注解的第二种方式
const names2: string[] = [] // 推荐

names1.push(123) // Error: 类型“number”的参数不能赋给类型“string”的参数。
```

1. 普通的声明方式

```ts
//类型加中括号
let arr: number[] = [123]
//这样会报错定义了数字类型出现字符串是不允许的
let arr: number[] = [1, 2, 3, "1"]
//操作方法添加也是不允许的 let arr:number[] = [1,2,3,]
let arr: number[] = [1, 2, 3, 4] //数字类型的数组
let arr2: string[] = ["1", "2", "3", "4"] //字符串类型的数组
let arr3: any[] = [1, "2", true, undefined, [], {}] //任意类型的数组

let arr4: number[][][] = [[[]], [[]], [[]]]
//这个也能够决定你二维数组还是三维数组想要套几层就写几层
```

2. 泛型 -- Array <类型>

```ts
let arr1: Array<number> = [1, 2, 3, 4, 5]
let arr2: Array<string> = ["1,2,3,4,5"]
let arr3: Array<boolean> = [true]

//泛型数组套娃写法(还能够决定数组里面数组的类型之类的)
let arr4: Array<Array<number>> = [[123], [456]]
```

3. 类数组 -- arguments

> 是所有参数的一个集合

```ts
function Arr(...args: any): void {
  //...args为ES6的解构方式，任意类型，不能有返回值
  console.log(arguments) //输出{'0':4,'1':56,'2':789}

  let arr: number[] = arguments //会报错，报缺少类型number[]的以下属性：pop,push,concat,join
  arr: IArguments = arguments //解决方法
  //其中 IArguments 是 TypeScript 中定义好了的类型，它实际上就是：
  interface IArguments {
    [index: number]: any
    length: number
    callee: Function
  }
}
Arr(4, 56, 789)
```

4. 接口表示数组

> 一般用来描述类数组

```ts
interface ArrNumber {
  [index: number]: number //后面的才是定义类型的
  //[index: number]: string;这个就是定义字符串的了
}
let Arr: ArrNumber = [1, 2, 3, 4, 5]
//let Arr: ArrNumber = ["1, 2, 3, 4, 5"];
//表示：只要索引的类型是数字时，那么值的类型必须是数字。
```

### 6.object

```ts
// 一般不推荐这样使用 info: object 否则会报错
const info: object = {
  name: "ZhangQiLong",
  age: 18,
}

console.log(info.name) // Error:类型“object”上不存在属性“name”
```

### 7.null 和 undefined

```ts
const n1: null = null
const n2: undefined = undefined
```

### 8.symbol

```ts
const info = {
  // 正常情况下一个对象里面 title1 和 title2 不能同名
  title1: "ZhangQiLong",
  title2: "teacher",
}

// 如果我们希望 title1 和 title2 都叫 title

const name1 = Symbol("name")
const name2 = Symbol("name")
const person = {
  [name1]: "程序员",
  [name2]: "ZhangQiLong",
}
export {}
```

## 五、TypeScript 的数据类型

### 1. any 类型

> 在某些情况下，我们无法确定一个变量的类型，并且可能它会发生一些变化，这个时候我们可以使用 any 类型 (类似于 Dart 语言中的 dynamic 类型)
>
> 1.  当进行一些类型断言: as any 就不会报错
> 2.  在不想给某些 JavaScript 添加具体的数据类型时(与原生的 JavaScript 代码就一样)

```ts
let message: string = "ZhangQiLong"

message = "abc"

// 需要将 message1 改成其他类型的话，就可以使用 any 类型
let message1: any = "ZhangQiLong"

message1 = 123
message1 = true
message1 = {}

// 也可以给数组里面的存放类型设为 any 但是不推荐，数组里面最好存放确定的数据类型
const any: any[] = []
```

### 2. unknown 类型

> 当变量的赋值类型不确定的时候可以使用 unknown 类型
>
> unknown 类型与 any 类型的区别：
>
> 1. unknown 类型只能赋值给 any 和 unknown 类型
> 2. any 类型可以赋值给任意类型

```ts
function foo() {
  return "abc"
}

function bar() {
  return 123
}

let flag = true
// 定义的时候没有写类型注解，但是这里一个是 string 类型一个是 number类型

// let result;
// 第一种方式使用联合类型
// let result: number | string;
// 第二种方式可以赋值为 any 类型，但是不推荐
// let result:any;
// 第三种方式可以赋值为 unknown 类型
let result: unknown

if (flag) {
  result = foo()
} else {
  result = bar()
}
export {}
```

> 3. unknown 类型和 any 类型的区别

```js
// unknown 与 any 类型的区别
// 1. 如果是 unknown 的话，那么这里就没有办法对其重新指定类型
let res: unknown = "ZhangQiLong"
let message: string = res // Error: 不能将类型“unknown”分配给类型“string”。

// 2. 如果是 any 类型的话，那就可以对其重新定义类型
let res1: any = "ZhangQiLong"
let message1: string = res1
export {}
```

### 3. void 类型

> void 通常用来指定一个函数是没有返回值的，那么它的返回值就是 void 类型
>
> - 我们可以将 undefined 赋值给 void 类型，也就是函数可以返回 undefined

```ts
function sum(num1: number, num2: number) {
  console.log(num1, num2)
}

sum(20, 30)
// sum("abc", "cba");
```

![image-20230115200854301](http://www.zhangqilong.cn/img/qlBlog_images/TypeScript/Learn_TypeScript/image-20230115200854301.png)

如果一个函数没有返回值，就会进行类型推断成 `void`

```ts
function sum(num1: number, num2: number): void {
  console.log(num1, num2)
  // 当定义函数是 void类型的时候，那么就没有返回值，并且可以返回 undefined
  return undefined
}

sum(20, 30)
```

### 4. never 类型

> never 表示永远不会发生值的类型，比如一个函数：
>
> - 如果一个函数中是一个死循环或者抛出一个异常，那么这个函数会返回东西么？
> - 不会，那么写 void 类型或者其他类型作为返回值类型都不合适，我们就可以使用 never 类型

```ts
function foo(): never {
  // 死循环的话，说明这个函数永远不会有返回结果，那么就可以指定一个 never类型
  while (true) {}
}

// 或者抛出异常的话，就可以执行一个 never 类型
function bar(): never {
  throw new Error()
}
```

> _never 应用在哪个场景_

```ts
// never 应用在哪个场景
function handleMessage(message: string | number) {
  switch (typeof message) {
    case "string":
      console.log("string处理方式处理string")
      break
    case "number":
      console.log("number处理方式处理number")
      break
    default:
      console.log("没有这种处理方式")
  }
}
handleMessage("abc")
handleMessage(123)
```

> 但如果不知道函数内部逻辑的人使用 handleMessage(true) 函数的时候，传入一个 boolean 类型的参数，使用者会将代码修改为以下

```ts
// never 应用在哪个场景
function handleMessage(message: string | number | boolean) {
  switch (typeof message) {
    case "string":
      console.log("string处理方式处理string")
      break
    case "number":
      console.log("number处理方式处理number")
      break
    default:
      console.log("没有这种处理方式")
  }
}
handleMessage("abc")
handleMessage(123)
handleMessage(true)
```

> 但是会发现，函数内部并没有对 boolean 类型的处理方式，并且这种方式是可以编译通过的，我们可以使用 never ，在类型是 never 的情况下编译就无法通过，提醒及时修改代码逻辑

```ts
// never 应用在哪个场景
function handleMessage(message: string | number | boolean) {
  switch (typeof message) {
    case "string":
      console.log("string处理方式处理string")
      break
    case "number":
      console.log("number处理方式处理number")
      break
    default:
      const check: never = message // 不能将类型“boolean”分配给类型“never”。
  }
}
handleMessage("abc")
handleMessage(123)
handleMessage(true)
```

```ts
// 封装Ajax请求
// 3. 定义一个类型取名为 Method
type Method = "GET" | "POST" | "PUT"
//1. method：请求方法 , url：请求地址
//2. 如果给 method 约束为 string 那么范围太广
function request(method: Method, url: string) {
  switch (method) {
    case "GET":
      return "请求方法是GET"
    case "POST":
      return "请求方法是POST"
    default:
      // never 可以赋值为 never ，其他类型不可以赋值为 never
      // 3. 比如我们这里给 method 添加一种方法（PUT），那么当没有 PUT 分支的时候，这里就会报错，因为 PUT string 类型不能赋值给 never
      const n: never = method
      return n
  }
}
```

### 5. tuple 元组类型

> tuple 元组：多种元素的结合，为了保证数组中只有相同元素，那么出现个人信息
>
> "zql",18,1.8 这种信息存储起来，就会有问题
> 比如取出来的是 number 类型没有 length 属性并且没有提示

#### 1. 数组的弊端

```ts
const info: any[] = ["zql", 18, 1.8]
const name = info[0]
console.log(name.length) // 如果是没有长度的数据，这样直接调用并且是 any 类型的话就会容易出错
```

#### 2.元组的特点

```ts
const info: [string, number, number] = ["zql", 18, 1.8]
const name = info[0]
console.log(name.length)

export {}
```

#### 3.tuple 的应用场景

```ts
// react里面有一个，hook函数 useState
// 当给 useState 传入参数之后，会返回一个数组，counter是传入的数据，setCounter是一个函数
// const [counter,setCounter] = useState(10)

function useState(state: any) {
  let currentState = state

  const changeState = (newState: any) => {
    currentState = newState
  }
  // const arr: any[] = [currentState, changeState];
  //1 这里可以替换为 tuple写法
  // 第一个参数是 any 类型，第二个是函数类型
  const arr: [any, (newState: any) => void] = [currentState, changeState]
  return arr
}
//2. 那么这里就会有提示，第一个是 any 类型，第二个就会提示是函数类型
const [counter, setCounter] = useState(10) // counter 提示为 any 类型

const [title, setTitle] = useState("zql") // title 提示为 string 类型
```

##### 对上面代码进行优化

> 如果我们期望，代码可以推断出，上面提示 any 的是什么类型的话，那么就需要使用 泛型 s

```ts
// react里面有一个，hook函数 useState
// 当给 useState 传入参数之后，会返回一个数组，counter是传入的数据，setCounter是一个函数
// const [counter,setCounter] = useState(10)

function useState<T>(state: T) {
  let currentState = state

  const changeState = (newState: T) => {
    currentState = newState
  }
  // const arr: any[] = [currentState, changeState];
  //1 这里可以替换为 tuple写法
  // 第一个参数是 any 类型，第二个是函数类型
  const arr: [T, (newState: T) => void] = [currentState, changeState]
  return arr
}
//2. 那么这里就会有提示，第一个是 any 类型，第二个就会提示是函数类型
const [counter, setCounter] = useState(10) // counter 提示为 number类型

const [title, setTitle] = useState("zql") // title 提示为 string 类型

const [flag, setFlag] = useState(true) // flag 提示为 boolean 类型
```

## 五、TypeScript 的数据补充

#### 1.函数的参数和返回值类型

```ts
// 更参数添加类型注解 num1: number, num2: number
// 给发回值添加类型注解 ():number
// 在开发中，通常情况下使不用写返回值类型的（自动推导）
function sum(num1: number, num2: number): number {
  return num1 + num2
}

sum(1, 2)
```

#### 2.匿名函数的参数类型

```ts
// 通常情况下，在定义一个函数时，都会给参数加上类型注解
function foo(message: string) {}

const names = ["abc", "cba", "nba"]

// 但是这里的 item 就可以不添加类型注解，可写不可写
// 因为 item 来自于数组，数组中的类型是确定的
// 上下文中的函数：可以不添加类型注解
names.forEach((item) => {})
```

#### 3.对象类型

```ts
// Point:x/y
// 参数传入对象类型
function printPoint(point: { x: number; y: number }) {
  console.log(point.x)
  console.log(point.y)
}

printPoint({ x: 123, y: 321 })
```

#### 4.可选类型

```ts
// Point:x/y
// {x:number,y:number,z?:number}
function printPoint(point: { x: number; y: number; z?: number }) {
  console.log(point.x)
  console.log(point.y)
  console.log(point.z)
}

printPoint({ x: 123, y: 321 })
printPoint({ x: 123, y: 321, z: 111 })

export {}
```

#### 5.联合类型

> TypeScript 的类型系统允许我们使用多种运算符，从现有类型中构建新类型
>
> 联合类型是由两个或者多个其他类型组成的类型，表示可以是这些类型中的任何一个值

```ts
function printID(id: number | string) {
  console.log(id)
}

printID(123)
printID("abc")
```

但是需要联合类型的值的时候需要特别注意

```ts
function printID(id: number | string) {
  console.log(id)
  // 如果想要将字符串类型转为大写，那么需要进行判断
  if (typeof id === "string") {
    // TypeScript 帮助确定 id 一定是 string 类型
    console.log(id.toUpperCase())
  } else {
    console.log(id)
  }
}

printID(123)
printID("abc")
```

#### 6.可选类型和联合类型的关系

```ts
// 一个参数是一个可选类型的时候，它其实本质上表示的是这个参数是 类型|undefined 的联合类型
function foo(message?: string) {
  console.log(message)
}
foo("123")
// 让我们一个参数变成可选的，那么这里就可以不传参数
foo() // undefined

// 如果没有使用可选类型的话，那么需要传入 undefined

function foo1(message: string | undefined) {
  console.log(message)
}
foo1(undefined)

export {}
```

#### 7.类型别名

```ts
// type 用于定义类型别名
type IDType = string | number | boolean
type PointType = {
  x: number
  y: number
  z?: number
}

// 没有使用类型别名的写法
function printID(id: string | number | boolean) {}

function printId(id: IDType) {}

function printPoint(point: PointType) {}

export {}
```

#### 8.类型断言

> 将范围大的类型转换成类型比较小更加精确的类型

```ts
// const el: HTMLElement | null
// 类型自动推导成了HTMLElement
const el = document.getElementById("zql")

// el.src = "url地址"  // 类型“HTMLElement”上不存在属性“src”

// 但是通过 getElementById 获取的元素可以是 img/div/span
// 没有办法更加具体的获取元素类型，那么要想更加具体的获得就需要使用类型断言
const el1 = document.getElementById("zql") as HTMLImageElement

el1.src = "url地址"
```

```ts
class Person {}

class Student extends Person {
  studying() {}
}

function sayHello(p: Person) {
  // 这里直接使用p.sayHello()调用方法会报错
  // 因为 p 是一个 Person 类型，但是只用 Person之下的 Student 才能调用 sayHello 方法
  // p.sayHello(); //报错 类型“Person”上不存在属性“sayHello”

  // 可以使用类型断言将大范围缩小为小范围
  ;(p as Student).studying()
}

const stu = new Student()
sayHello(stu)

export {}
```

#### 9.非空类型断言

```ts
function printMessageLength(message?: string) {
  // 如果我们想要这里编译通过的话需要添加一个判断
  // 因为使用了可选类型之后，这个类型就变成了 string | undefined
  if (message) {
    console.log(message.length)
  }
}

printMessageLength("Hello World") //11

// 或者使用非空类型断言
function printMessageLength1(message?: string) {
  // message! 表示 message 一定有值，就不需要进行判断了
  console.log(message!.length)
}
```

#### 10.可选链的使用

> 可选链事实上并不是 TypeScript 独有的特性，它是 ES11(ES2020)中增加的特性
>
> - 可选链使用可选链操作符 ?.
> - 它的作用是当对象的属性不存在时，会短路，直接返回 undefined，如果存在那么才会继续执行
> - 虽然可选链操作时 ECMAScript 提出的特性，但是和 TypeScript 一起使用更版本

```ts
type Person = {
  name: string
  friend?: {
    name: string
    age?: number
  }
}

const info: Person = {
  name: "zql",
  friend: {
    name: "James",
  },
}

// 另一个文件中
console.log(info.name)
// 有可能能取出来，有可能是 undefined
// console.log(info.friend.name); // “info.friend”可能为“未定义”。

//friend!.name 但是这样会出现一个问题，如果 info 里面没有 friend
//即 friend是undefined 那么 undefined.name就会报错
// console.log(info.friend!.name);

// 第三种，可以使用可选链
// 如果 friend 有值就取值，如果没有就不取 friend
console.log(info.friend?.name) // James
console.log(info.girlFriend?.name) // undefined
```

#### 11. !!操作符和??操作符

> !!操作符：
>
> - 将一个其他类型转换成 boolean 类型
>
> - 类似于 Boolean(变量) 的方式
>
> ??操作符：
>
> - 它是 ES11 增加的新特性
> - 空值合并操作符（??）是一个逻辑操作符，当操作符的左侧是 null 或者是 undefined 时，返回其右侧操作数，否则返回左侧操作数

```ts
const message = "Hello World"
// 将 message 转成 boolean 类型再赋值给 flag

// 第一种
const flag = Boolean(message)

// 第二种
// !message 是 JavaScript 中 !message 取反是 false 再取反就是 true
const flag1 = !!message

console.log(flag)

export {}
```

```ts
// 第一种
let message: string | null = null

const content = message ?? "ZhangQiLong"
console.log(content) // 使用默认值 ZhangQiLong

// 第二种
let message1: string | null = "Hello"
const content1 = message1 ?? "ZhangQiLong"
console.log(content) // Hello

// 相当于三元运算符
const content2 = message ? message : "ZhangQiLong"
```

#### 12.字面量类型

> 默认情况下这么做事没有太大意义的，但是我们可以将多个联合类型联合在一起

```ts
const message: string = "Hello World"

// "Hello" 也是可以作为类型的，叫做字面量类型
const message1: "Hello" = "Hello"

// 需要注意的是 字面量类型的类型需要和值保持一致
let num: 123 = 123
// num = 321;  // 不能将类型“321”分配给类型“123”。

// 字面量类型的意义，就是必须结合联合类型
let align: "left" | "right" | "center" = "left"
align = "right"
align = "center"

// 改进
type Alignment = "left" | "right" | "center"
let align1: Alignment = "left"
align1 = "right"
align1 = "center"

export {}
```

#### 13.字面量推理

> 出现问题

```ts
// 报错：
type Method = "GET" | "POST"
function request(url: string, method: Method) {}
const options = {
  url: "http://www.zhangqilong.cn/abc",
  method: "POST",
}
request(options.url, options.method)
// 这样传值就会报错 类型“string”的参数不能赋给类型“Method”的参数。
// 因为 string 类型除了"GET" | "POST"还可以是其他的
// 但 options.method 传入的必须是 Method 约束下的方法 "GET" | "POST";
```

> 解决办法一：

```ts
type Method = "GET" | "POST"
function request(url: string, method: Method) {}
const options = {
  url: "http://www.zhangqilong.cn/abc",
  method: "POST",
}
// 使用类型断言，把 string 类型转化成了 Method 约数下的 "GET"|"POST"
request(options.url, options.method as Method)
```

> 解决办法二： 推荐使用

```ts
type Method1 = "GET" | "POST"
function request1(url: string, method: Method1) {}
type Request = {
  url: string
  method: Method
}
const options1: Request = {
  url: "http://www.zhangqilong.cn/abc",
  method: "POST",
}
request(options1.url, options1.method)
```

> 解决办法三： 官方文档

```ts
type Method2 = "GET" | "POST"
function request2(url: string, method: Method2) {}
const options2 = {
  url: "http://www.zhangqilong.cn/abc",
  method: "POST",
} as const
request(options2.url, options2.method)
```

#### 14.类型缩小

> 什么是类型缩小呢？
>
> - 类型缩小的英文是 Type Narrowing
> - 我们可以通过类似于 typeof padding === "number" 的判断语句，来改变 TypeScript 的执行路径
> - 在给定的执行路径中，我们可以缩小比声明时更小的类型，这个过程称之为 缩小
> - 而我们编写的 typeof padding === "number" 可以称之为 类型保护 ( type guards )

> 常见的类型保护有如下几种：
>
> - typeof
> - 平等缩小（比如===、!==）
> - instanceof
> - in
> - 等等

##### 14.1 typeof

> 在 TypeScript 中，检查返回的值 typeof 是一种类型保护：因为 TypeScript 对如何 typeof 操作不用的值进行编码

```ts
type IDType = number | string
function printID(id: IDType) {
  // 下面的整个判断语句称之为类型缩小，在 if 判断中的做类型保护
  if (typeof id === "string") {
    // 在这里就可以判断是 string 类型
    console.log(id.toUpperCase())
  } else {
    // 这里就是 number 类型
    console.log(id)
  }
}

export {}

// 把本来是 string 和 number 的联合类型缩小成了 string 类型或者是 number 类型
```

##### 14.2 平等的类型缩小

> === 、==、!==、!=、switch

```ts
// 2. 平等的类型缩小(=== 、==、!==、!=、switch)

type Direction = "left" | "right" | "top" | "bottom"
function printDirection(direction: Direction) {
  console.log(direction) // 类型是 direction 说明是上面四个的其中一个
  // if (direction === "left") {
  //   console.log(direction);
  // } else if (direction === "right") {
  // }
  switch (direction) {
    case "left":
      // 这里可以确定一定是 left
      console.log(direction)
      break
  }
}
```

##### 14.3 instanceof

> 与其他的类型缩小的区别就是，这里需要创建实例，然后传入方法中

```ts
//3. instanceof

function printTime(time: string | Date) {
  // 可以判断这个对象是不是 Date 的实例，如果是 Date 的实例就可以调用里面的方法
  if (time instanceof Date) {
    // 转成 UTC 的 string
    console.log(time.toUTCString())
  } else {
    console.log(time)
  }
}

// 如果自己创建类和实例

class Student {
  studying() {}
}

class Teacher {
  teaching() {}
}

function work(p: Student | Teacher) {
  if (p instanceof Student) {
    p.studying()
  } else {
    p.teaching()
  }
}
const stu = new Student()
work(stu)
```

##### 14.4 in

```ts
//4. in

type Fish = {
  // swimming:函数的 key
  // () => void : 表示是一个函数类型
  swimming: () => void
}

type Dog = {
  running: () => void
}

function walk(animal: Fish | Dog) {
  // 这里还不确定是 Fish 还是 Dog 不能直接 animal.swimming()调用方法
  // 如果是 new Student() 创建出来的实例那么就是 instanceof 判断
  // 但是这里仅仅是个 字面量 fish 只不过字面量是 Fish 的类型而已
  if ("swimming" in animal) {
    // 这里就可以确定一定是 Fish
    animal.swimming()
  } else {
    animal.running()
  }
}

// 如果是 class 类的话就是 new 出来一个实例
// 但是这里仅仅是类型别名
const fish: Fish = {
  swimming() {
    console.log("swimming")
  },
}

walk(fish)
```

## 六、TypeScript 的函数类型

> 在 JavaScript 开发中，函数是重要的组成部分，并且函数可以作为一等公民（可以作为参数，也可以作为返回值进行传递）
>
> 那么在函数的过程中，函数是否也可以有自己的类型呢？
>
> - 我们可以编写函数类型的表达式（Function Type Expression）,来表示函数类型

> 为什么函数有类型呢？

```ts
// 为什么函数有类型呢？
function foo() {}

function bar(fn) {
  fn()
}

// 既然要执行传入的函数就不能是 number 或者是 string 类型
// function bar(fn: number|string) {
//   fn();
// }

// 在 JavaScript 中可以将 foo 函数作为参数传入到 bar 函数中执行
bar(foo)
```

> 1. 函数作为参数时，在参数中如何编写类型

```ts
function fn(fn: () => void) {
  fn()
}
```

> 2.定义常量时，编写函数的类型
>
> `(num1:number,num2:number) => void` 代表的是一个函数类型
>
> - 接收两个参数的函数：`num1`和 `num2`，并且都是 number 类型
> - 并且这个函数是没有返回值的所以是 void
>
> 特别注意在其他的语言中指定函数类型的时候，可以省略为 `(number, number) => void`
>
> 但是在 TS 中是不可以这样省略的，省略之后会被认为是 `(number:any, number:any) => void`

```ts
// 2.定义常量时，编写函数的类型

const add = (num1: string, num2: string) => {
  return num1 + num2
}

// 这里指定类型的时候也是需要指定参数的
// (num1, num2) => void
// 甚至于加上

const add1: (num1: number, num2: number) => void = (
  num1: number,
  num2: number
) => {
  return num1 + num2
}
```

```ts
// 指定函数有两个参数 num1 和 num2 类型是 number 并且返回值是 number
type AddType = (num1: number, num2: number) => number
const add2: AddType = (a1: number, a2: number) => {
  return a1 + a2
}
```

> 函数类型的案例

```ts
// 函数不确定是要做什么计算
// calc(add) calc(mul) 接收另外一个函数确定是做什么计算

function calc(
  n1: number,
  n2: number,
  fn: (num1: number, num2: number) => number
) {
  return fn(n1, n2)
}
// 这里是将一个函数传给上面的函数
const result = calc(20, 30, function (a1, a2) {
  return a1 + a2
})

console.log(result) // 50
```

#### 参数的可选类型

> 可选类型必须写在必选类型的后面

```ts
// 可选类型必须写在必选类型的后面
function foo(x: number, y?: number) {}
foo(20, 30)
```

> y -> undefined |number
>
> 如果不传入第二个参数的话需要传入 undefined

```ts
function foo(x: number, y?: number) {}
foo(20, undefined)
```

#### 参数的默认值

> 函数参数可以按照 `必传参数 - 有默认值的参数 - 可选参数` 的顺序

```ts
function foo(x: number = 20, y: number) {
  console.log(x, y)
}

foo(20, 30)
foo(undefined, 30)
// 需要注意的是这里不可以传入 null 因为 null 不可以赋值给 undefined

// 所以在开发中最好写成 必传参数 - 有默认值的参数 - 可选参数 的顺序编写
function foo1(y: number, x: number = 20) {
  console.log(x, y)
}
// 这样有默认值的参数就可以不传
foo1(30)
```

#### 函数的剩余参数

```ts
function sum(num1: number, num2: number) {
  return num1 + num2
}

// sum 函数可以对任意多个参数进行相加
function sum1(...nums: number[]) {}

sum1(1, 2, 3, 4)
export {}
```

```ts
function sum(initalNum: number, ...nums: number[]) {
  let total = initalNum
  for (const num of nums) {
    total += num
  }
  return total
}

console.log(sum(20, 30))
console.log(sum(20, 30, 40))
console.log(sum(20, 30, 40, 50))
```

#### 可推导的 this 类型

> this 是 JavaScript 中一个比较难以理解和把握的知识点：
>
> - 因为 this 在不同的情况下会绑定不同的值，所以对于它的类型就更难把握了；
>
> 那么，TypeScript 是如何处理 this 呢？我们先来看一个例子：
>
> 代码是可以正常运行的，也就是 TypeScript 在编译时，认为我们的 this 是可以正确去使用的：
>
> - TypeScript 认为函数 sayHello 有一个对应的 this 的外部对象 info，所以在使用时，就会把 this 当做该对象。

```ts
// this 是可以被推导出来的 info对象（typeScript 推导出来）
const info = {
  name: "zql",
  eating() {
    console.log(this.name + " eating")
  },
}

info.eating()
```

#### 不确定的 this 类型

> - 但是对于某些情况来说，我们并不知道 this 到底是什么？
> - 通常 TypeScript 会要求我们明确的指定 this 的类型

```ts
type ThisType = { name: string }

function eating(this: ThisType, message: string) {
  console.log(this.name + " eating", message)
}

const info = {
  name: "zql",
  eating,
}
// 隐式绑定
info.eating("哈哈哈")
// 显式绑定
eating.call({ name: "kobe" }, "呵呵呵")
eating.apply({ name: "james" }, "嘿嘿嘿 ")
```

#### 函数的重载

> 在 TypeScript 中，如果我们编写一个 add 函数，希望可以对字符串和数字类型进行相加，应该如何做
>
> - 方案一：使用联合类型实现
> - 方案二：使用函数的重载实现

```ts
// 报错：
function add(a1: number | string, a2: number | string) {
  // return a1 + a2; // 运算符“+”不能应用于类型“string | number”和“string | number”。
}
```

> 通过联合类型有两个缺点
>
> - 进行很多的逻辑判断(类型缩小)
> - 返回值的类型依然是不确定的

```ts
function add1(a1: number | string, a2: number | string) {
  if (typeof a1 === "number" && typeof a2 === "number") {
    return a1 + a2
  } else if (typeof a1 === "string" && typeof a2 === "string") {
    return a1 + a2
  }
}
```

> 函数重载的方法实现
>
> 将函数类型声明和函数的实现分开

```ts
// 函数的重载：函数的名称相同，但是参数不同的几个函数就是函数的重载

function add(num1: number, num2: number): number
function add(num1: string, num2: string): string
function add(num1: any, num2: any): any {
  return num1 + num2
}
// 这样写就匹配到了第一个函数，但是第一个却没有函数的实现，然后就会匹配到第三个函数进行函数实现
console.log(add(20, 30))

console.log(add("zql", "zhang"))

// 既然实现函数中传入的参数是 any
// 但是在函数的重载中，实现函数是不能直接被调用的
// add({ name: "zql" }, { age: 18 });

export {}
```

#### 函数的重载练习

> 能使用联合类型尽量使用联合类型

```ts
// 实现一个获取长度的函数
// 方案一：联合类型
function getLength(args: string | any[]) {
  return args.length
}
console.log(getLength("abc"))
console.log(getLength([123, 321, 123]))

// 实现二：函数的重载
function getLength1(args: string): number
function getLength1(args: any[]): number
function getLength1(args: any): number {
  return args.length
}

console.log(getLength1("abc"))
console.log(getLength1([123, 321, 123]))

export {}
```

## 七、TypeScript 类的使用

#### 1. 类的定义

> 编程范式：
>
> - 面向对象编程：C++ / JAVA
> - 函数式编程：JavaScript、lisp

```ts
// 第一种方式在创建类的时候直接初始化
class Person {
  // 属性和方法
  // name: string;
  // age: number;
  // 在 TypeScript 的严格模式下 name 和 age 必须初始化
  name: string = ""
  age: number = 0
  eating() {
    console.log(this.name + "eating")
  }
}
const p = new Person()

// 第二种方式在类的 constructor 中进行初始化
class Student {
  name: string
  age: number
  constructor(name: string, age: number) {
    this.name = name
    this.age = age
  }
  eating() {
    console.log(this.name + "eating")
  }
}

// 这里必须要传入参数，否则就会报错
const stu = new Student("zql", 23)
export {}
```

#### 2. 类的继承

> JavaScript 中类的继承

```ts
// 不使用继承
class Student1 {
  name: string = ""
  age: number = 0
  sno: number = 0
  eating() {
    console.log("eating")
  }
  studying() {
    console.log("studying")
  }
}

class Teacher1 {
  name: string = ""
  age: number = 0
  title: string = ""
  eating() {
    console.log("eating")
  }
  teaching() {
    console.log("teaching")
  }
}

// 使用继承
class Person {
  name: string = ""
  age: number = 0
  eating() {
    console.log("eating")
  }
}

class Student extends Person {
  sno: number = 0
  studying() {
    console.log("studying")
  }
}

class Teacher extends Person {
  title: string = ""
  teaching() {
    console.log("teaching")
  }
}

const stu = new Student()
stu.name = "ZhangQiLong"
stu.age = 23
console.log(stu.name)
console.log(stu.age)
stu.eating()

export {}
```

> TypeScript 中类的继承

```ts
class Person {
  name: string
  age: number
  constructor(name: string, age: number) {
    this.name = name
    this.age = age
  }
  eating() {
    console.log("eating")
  }
}

class Student extends Person {
  sno: number
  constructor(name: string, age: number, sno: number) {
    // super可以调用父类里面的构造方法 constructor
    super(name, age)
    this.sno = sno
  }
  studying() {
    console.log("studying")
  }
  // 对父类中的方法进行重写
  eating() {
    // 并且执行父类里面的代码
    super.eating()
    console.log("eating 100")
  }
}

class Teacher extends Person {
  title: string
  teaching() {
    console.log("teaching")
  }
}

const stu = new Student("zql", 18, 12)
stu.name = "ZhangQiLong"
stu.age = 23
console.log(stu.name)
console.log(stu.age)

// 会先去子类中找 eating() 方法，如果有就用子类的，如果没有就去父类里面查找
// 当然也可以进行重写
stu.eating()

export {}
```

#### 3.类的多态

> 多态：父类引用（类型）指向子类对象

```ts
class Animal {
  action() {
    console.log("animal action")
  }
}

class Dog extends Animal {
  action() {
    console.log("dog running!")
  }
}

class Fish extends Animal {
  action() {
    console.log("fish swimming")
  }
}

// 传入数组（animal:dog/fish）中，遍历分别执行每个实例化对象的 action() 方法
function makeActions(animals: Animal[]) {
  animals.forEach((animal) => {
    // 由于多态的存在，那么这里一定会执行，继承父类重写之后的 action()方法
    animal.action() // dog running
  })
}

// 创建实例化对象传入 makeActions 方法中
makeActions([new Dog(), new Fish()])
```

> 多态分析

```ts
// 在上面的例子中，由于多态的存在，所以执行的是子类中的 action 方法，结果是 dog running 而并非是 animal action

// 多态：父类引用（类型）指向子类对象
const animal: Animal = new Dog()
animal.action()
// 虽然这里是调用的 animal.action()，看到是拿到animal，但其实还是 new Dog() 产生的拿到的 dog，所以调用的时候会执行 Dog 中的方法
```

> 不管是 dog 还是 fish，虽然看到的都是拿到相同的类型 animal，但是执行方法的时候，表现出来的形态却是不一样，这个过程就是多态，多态的目的就是写成通用性的代码

> 如果不用多态，可以使用函数的重载，但是不推荐

```ts
function makeActions(animals: Dog[])
function makeActions(animals: Fish[])
function makeActions(animals: Animal[]) {
  animals.forEach((animal) => {
    animal.action()
  })
}
makeActions([new Dog(), new Fish()])
```

> 或者可以使用联合类型，但是不推荐

```ts
function makeActions(animals: (Dog | Fish)[]) {
  animals.forEach((animal) => {
    animal.action()
  })
}
makeActions([new Dog(), new Fish()])
// 这样写的弊端就是 如果再有一个实例继承父类
class Person extends Animal {}
// 那么就需要再增加
function makeActions(animals: (Dog | Fish | Person)[]) {
  animals.forEach((animal) => {
    animal.action()
  })
}
makeActions([new Dog(), new Fish(), new Person()])
```

> 如果使用多态增加就只需要，在下面传入参数即可

```ts
class Animal {
  action() {
    console.log("animal action")
  }
}

class Dog extends Animal {
  action() {
    console.log("dog running!")
  }
}

class Fish extends Animal {
  action() {
    console.log("fish swimming")
  }
}
// 增加一个 Person 类
class Person extends Animal {}

function makeActions(animals: Animal[]) {
  animals.forEach((animal) => {
    animal.action()
  })
}
// 调用方法的时候在数组中直接添加一个实例化对象即可
makeActions([new Dog(), new Fish(), new Person()])
```

#### 4. 类的成员修饰符

> 在 TypeScript 中，类的属性和方法支持三种修饰符：public、private、protected
>
> - public 修饰的是在任何地方可见、公有的属性或方法，默认编写的属性就是 public 的
> - private 修饰的是仅在同一类中可见、私有的属性或方法
> - protected 修饰的是仅在类自身及子类中可见、受保护的属性或方法

> public

```ts
class Person {
  // 默认情况下就是公用的 public
  public name: string = ""
}

const p = new Person()
console.log(p.name)
```

> private
>
> 规范，私有属性 `_` 开头

```ts
class Person1 {
  private _name: string = ""
  getName() {
    return this.name
  }
  setName(newName) {
    this.name = newName
  }
}

const p1 = new Person1()
// console.log(p1.name); //Error:属性“name”为私有属性，只能在类“Person1”中访问
// 如果想要访问可以通过 get、set
console.log(p1.getName())
p1.setName("zql")
```

> protected : 在类内部和子类中可以访问

```ts
// protected:在类内部和子类中可以访问

class Person {
  protected name: string = "zql"
}
class Student extends Person {
  getName() {
    // 执行这段代码首先会在子类中查找有没有 name 然后再去父类中查找
    // protected 在子类中可以访问到 所以这里是 "zql"
    return this.name
  }
}

const stu = new Student()
const stuName = stu.getName()
// 在外面就不能访问到了
// console.log(stu.name);  // Error：属性“name”受保护，只能在类“Person”及其子类中访问。

console.log(stuName) // zql
```

#### 5. 只读属性 readonly

```ts
class Person {
  readonly name: string = "ZhangQiLong"
}
const p = new Person()
// p.name = "zql"; // Error:无法为“name”赋值，因为它是只读属性。
console.log(p.name) // ZhangQiLong
```

> 只读属性可以在 constructor 中赋值，但是赋值之后就不可以修改了

```ts
// 只读属性可以在 constructor 中赋值，但是赋值之后就不可以修改了

class Student {
  readonly name: string = "123"
  constructor(name: string) {
    this.name = name
  }
}
const stu = new Student("233")
console.log(stu.name)

export {}
```

```ts
// 3.
class Friend {
  readonly name: string = "123"
  // 指定朋友是 Person 类型的，并且是可选的
  readonly friend?: Person
  constructor(name: string, friend?: Person) {
    this.name = name
    this.friend = friend
  }
}
const f = new Friend("233", new Friend("james"))
console.log(f.name)

// 不可以直接修改 friend
// p.friend = new Person("kobe");

// if (f.friend) {
//   f.friend = "kobe"; // 无法为“friend”赋值，因为它是只读属性。
// }

export {}
```

#### 6. getter/setter

> setter

```ts
class Person {
  // 规范，私有属性 _开头
  private _name: string
  constructor(name: string) {
    this._name = name
  }
  // 访问器 setter/getter
  set name(newName) {
    this._name = newName
  }
  get name() {
    return this._name
  }
}

const p = new Person("zql")
p.name = "ZhangQiLong"
console.log(p.name) // ZhangQiLong

export {}
```

#### 7. 类的静态成员 static

```ts
class Person {
  name: string = ""
  age: number = 12
}

const p = new Person()
p.name = "123"

class Student {
  static time: string = "20:00"
  static attendClass() {
    console.log("去学习")
  }
}

// 静态属性可以直接通过 类访问
console.log(Student.time) // 20:00
Student.attendClass() // 去学习
```

#### 8. 抽象类 abstract

> 我们知道，继承是多态使用的前提
>
> - 所以在定义很多通用的 **调用接口时，我们通常会让调用者传入父类，通过多态来实现更加灵活的调用方式**
> - 但是，**父类本身可能并不需要对某写方法进行具体的实现，所以父类中定义的方法，我们可以定义为抽象方法**
> - **并且抽象函数必须写在抽象类中，抽象类不能被实例化，抽象类中的方法必须被子类实现**
>
> 什么是抽象方法？在 TypeScript 中没有具体实现的方法(没有方法体)，就是抽象方法
>
> - 抽象方法，必须存在于抽象类中
>
> - 抽象类是使用 `abstract` 声明的类
>
> 抽象类有如下特点:
>
> - 抽象类是不能被实例的话（也就是不能通过 `new` 创建）
> - 抽象方法必须被子类实现，否则该类必须是一个抽象类

```ts
/**
 * 根据不同的图形，切换不同的计算方法
 * makeArea("三角形")
 * makeArea("矩形")
 */

function makeArea(shape: any) {
  // 那么这个里面就不能写计算代码了，要是写就需要一直判断
  return shape.getArea()
}

// 矩形
class Rectangle {
  private width: number
  private height: number
  constructor(width: number, height: number) {
    this.width = width
    this.height = height
  }
  getArea() {
    return this.width * this.height
  }
}

// 圆形
class Circle {
  private r: number
  constructor(r: number) {
    this.r = r
  }
  getArea() {
    return this.r * this.r * 3.14
  }
}

// 创建出一个矩形
const rectangle = new Rectangle(20, 30)

// 创建出一个圆形
const circle = new Circle(10)

console.log(makeArea(rectangle))
console.log(makeArea(circle))
```

> 但是上面代码会有一个弊端就是，传入的参数是 any，那么也就意味着，所有类型的参数都可以传入
>
> 比如 `makeArea(undefined)` 但是 undefined 是没有对应的 getArea() 方法的，代码不严谨

> 解决办法：
>
> 我们可以创建一个类 Shape 然后让子类继承 Shape 类，并且规定 makeArea 函数的 `shape` 参数类型为 Shape

```ts
/**
 * 根据不同的图形，切换不同的计算方法
 * makeArea("三角形")
 * makeArea("矩形")
 * 迭代1：修复 shape: any 可以随便传入参数的问题  makeArea(undefined)
 */

function makeArea(shape: Shape) {
  // 那么这个里面就不能写计算代码了，要是写就需要一直判断
  return shape.getArea()
}

// 创建父类
class Shape {
  getArea() {}
}

// 矩形
class Rectangle extends Shape {
  private width: number
  private height: number
  constructor(width: number, height: number) {
    super()
    this.width = width
    this.height = height
  }
  getArea() {
    return this.width * this.height
  }
}

// 圆形
class Circle extends Shape {
  private r: number
  constructor(r: number) {
    super()
    this.r = r
  }
  getArea() {
    return this.r * this.r * 3.14
  }
}

// 创建出一个矩形
const rectangle = new Rectangle(20, 30)

// 创建出一个圆形
const circle = new Circle(10)

console.log(makeArea(rectangle))
console.log(makeArea(circle))

// 这样再随便传入就不可以了
// makeArea(123); // Error:类型“number”的参数不能赋给类型“Shape”的参数。

export {}
```

> 但是上面有会有问题就是 可以传入 `makeArea(new Shape())` 进去，但是在 Shape 类中没有实现体，并且我们在 Shape 的类中也没办法写实现体，因为不知道是那种类型的图形传进来，那么我们就可以写成抽象函数
>
> 并且抽象函数必须写在抽象类中，抽象类不能被实例化，抽象类中的方法必须被子类实现

```ts
// 所以将上面的 Shape 类修改为如下的代码
abstract class Shape {
  abstract getArea() {}
}
// 这样再写 makeArea(new Shape()) 就会被报错，因为抽象类不能被实例化
```

> 最终代码

```ts
/**
 * 根据不同的图形，切换不同的计算方法
 * makeArea("三角形")
 * makeArea("矩形")
 * 迭代2：修复 makeArea(new Shape()) 传入实例化对象的问题，可以使用抽象类
 * 并且抽象函数必须写在抽象类中，抽象类不能被实例化，抽象类中的方法必须被子类实现
 */

function makeArea(shape: Shape) {
  // 那么这个里面就不能写计算代码了，要是写就需要一直判断
  return shape.getArea()
}

// 抽象类
abstract class Shape {
  abstract getArea()
}

// 矩形
class Rectangle extends Shape {
  private width: number
  private height: number
  constructor(width: number, height: number) {
    super()
    this.width = width
    this.height = height
  }
  // 抽象类中的方法必须被子类实现
  getArea() {
    return this.width * this.height
  }
}

// 圆形
class Circle extends Shape {
  private r: number
  constructor(r: number) {
    super()
    this.r = r
  }
  // 抽象类中的方法必须被子类实现
  getArea() {
    return this.r * this.r * 3.14
  }
}

// 创建出一个矩形
const rectangle = new Rectangle(20, 30)

// 创建出一个圆形
const circle = new Circle(10)

console.log(makeArea(rectangle))
console.log(makeArea(circle))

// makeArea(new Shape()); // Error:无法创建抽象类的实例
export {}
```

#### 9.类的类型

```ts
class Person {
  name: string = ""
  eating() {}
}

const p = new Person()

const p1: Person = {
  // 这里面的成员必须和上面类中的一致，比如上面有 name 这里也必须有
  name: "zql",
  eating() {},
}

// 使用案例
function printPerson(p: Person) {
  console.log(p.name)
}
// 要求传入的是类的实例
printPerson(new Person())
// 上面要求传入的是类的实例，这里也可以传入对象
printPerson({ name: "kobe", eating: function () {} })

export {}
```

## 八、TypeScript 接口

#### 1. 声明对象类型

> 声明对象类型的方式
>
> 规范在接口面前多加一个 I 来表示这个是个接口

```ts
//方式一声明对象类型：
const info: { name: string; age: number } = {
  name: "zql",
  age: 23,
}

//方式二声明对象类型： 复用对象类型 通过类型别名来声明对象类型
type InfoType = { name: string; age: number }

const info1: InfoType = {
  name: "zql",
  age: 23,
}
```

> 接口 Interface
>
> - 在其中可以定义可选类型
> - 也可以定义只读属性

```ts
//方式三声明对象类型：接口 interface
// 规范在接口面前多加一个 I 来表示这个是个接口
interface IInfoType1 {
  name: string
  age: number
  // 接口可以写可选类型
  friend?: {
    name: string
  }
}

const info3: IInfoType1 = {
  name: "zql",
  age: 23,
  friend: {
    name: "james",
  },
}

// 取值通过可选链来取值
console.log(info3.friend?.name)
```

#### 2.索引类型

> Interface 定义类型

```ts
// 如何告诉在这个对象里面的 key 是索引，value 是字符串
// Interface 定义索引类型
interface IndexLanguage {
  // 索引是 number 类型，值是 string 类型
  [index: number]: string
}
const frontLanguage: IndexLanguage = {
  0: "HTML",
  1: "CSS",
  2: "JavaScript",
  3: "Vue",

  // aaa: "bbb", // Error:不能将类型“{ 0: string; 1: string; 2: string; 3: string; aaa: string; }”分配给类型“IndexLanguage”。
  // 对象字面量只能指定已知属性，并且“aaa”不在类型“IndexLanguage”中。t
}
```

##### 2.1 定义函数类型

> 不使用接口定义函数类型
>
> 除非特别的情况，还是推荐使用类型别名来定义函数

```ts
type CalcFn = (n1: number, n2: number) => number

function calc(num1: number, num2: number, calcFn: CalcFn) {
  return calcFn(num1, num2)
}

const add: CalcFn = (num1, num2) => {
  return num1 + num2
}

calc(20, 30, add)
```

> 使用接口定义函数类型

```ts
// 可调用接口
interface CalcFn {
  (n1: number, n2: number): number
}

function calc(num1: number, num2: number, calcFunc: CalcFn) {
  return calcFunc(num1, num2)
}

const add: CalcFn = (num1, num2) => num1 + num2
calc(20, 30, add)
```

#### 3.接口继承

> 接口和类一样是可以进行继承的，也是使用 extends 关键字：
>
> - 并且会发现，接口是支持多继承的（类不支持多继承）

```ts
interface ISwim {
  swimming: () => void
}

interface IFly {
  flying: () => void
}
// 相当于把前面两个接口合并成一个
interface IAction extends ISwim, IFly {}

const action: IAction = {
  swimming() {},
  flying() {},
}
```

#### 4.交叉类型

> 联合类型表示多个类型中一个即可
>
> 交叉类型：
>
> - 交叉类似表示需要满足多个类型的条件； p 交叉类型使用 & 符号；
> - 表达的含义是 number 和 string 要同时满足；
> - 但是有同时满足是一个 number 又是一个 string 的值吗？其实是没有的，所以 MyType 其实是一个 never 类型；
>
> 交叉类型的应用

```ts
// 一种组合类型的方式：联合类型
type WhyType = number | string

type Direction = "left" | "right" | "center"

// 另一种组合类型的方式：交叉类型
// type WType = number & string // never 没有意义
interface ISwim {
  swimming: () => void
}

interface IFly {
  flying: () => void
}
type MyType1 = ISwim | IFly
type MyType2 = ISwim & IFly

const obj1: MyType1 = {
  swimming() {},
}
const obj2: MyType2 = {
  swimming() {},
  flying() {},
}
```

#### 5.接口的实现

> 接口的一些使用

```ts
// 第一种
interface ISwim {
  swimming: () => void
}

// 第二种
interface IEat {
  eating: () => void
}

// 第三种
const a: ISwim = {
  swimming() {},
}

// 第四种
function foo(swim: ISwim) {}
// 别人用的时候需要 foo() 在里面传入符合 ISwim 的对象
```

> 类实现接口
>
> 继承：只能实现单继承
>
> 实现：实现接口,类可以实现多个接口

```ts
// 类实现接口
// 应用：编写一些公共的 API:面向接口编程
class Animal {}
// 继承: 只能实现单继承
// 实现: 实现接口,类可以实现多个接口
class Fish extends Animal implements ISwim, IEat {
  swimming() {
    console.log("Fish Swimming")
  }
  eating() {
    console.log("Fish Eating")
  }
}
```

> 类实现接口的一些应用
>
> 第一种方式：编写一些公共的 API:面向对象编程

```ts
// 编写一些公共的 API: 面向对象编程
function swimAction(swimable: Fish) {
  swimable.swimming()
}
// 这样编写的接口就不具备通用性，因为这里只能将鱼传入进来
swimAction(new Fish())
// 按理说，所有会游的动物都可以传入进来调用 swimming() 方法
// swimAction({swimming:function()}) // Error: 类型“{ swimming: () => never; }”的参数不能赋给类型“Fish”的参数。
```

> 第二种方式：编写一些公共的 API:面向接口编程

```ts
// 应用：编写一些公共的 API:面向接口编程
// 编写一些公共的 API: 面向接口编程
function IswimAction(swimable: ISwim) {
  swimable.swimming()
}
// 1.所有实现了接口的类对应的对象，都是可以传入的
// 比如 Fish 实现了接口
IswimAction(new Fish())

// 比如人也实现了接口
class Person implements ISwim {
  swimming() {
    console.log("Person Swimming")
  }
}
IswimAction(new Person())

// 甚至于普通的对象字面量，只要符合接口的类型也可以传入其中
IswimAction({ swimming: function () {} })
```

#### 6.interface 和 type 区别

> 我们会发现 interface 和 type 都可以用来定义对象类型，那么在开发中定义对象类型时，到底选择哪一个呢？
>
> - 如果是定义非对象类型，通常推荐使用 type，比如 Direction、Alignment、一些 Function
>
> 如果是定义对象类型，那么他们是有区别的：
>
> - interface 可以重复的对某个接口来定义属性和方法；
> - 而 type 定义的是别名，别名是不能重复的；

```ts
interface IFoo {
  name: string
}

interface IFoo {
  age: number
}
// 当两个接口名字相同时，是将两个接口进行合并
const foo: IFoo = {
  name: "zql",
  // Error: 类型 "{ name: string; }" 中缺少属性 "age"，但类型 "IFoo" 中需要该属性。ts(2741)
  age: 18,
}

export {}
```

> 定义接口给 window 上面添加 age，这样就将 window 合并了，所以就填加了 age 属性

```ts
// 如何给 window 上添加 age 属性
// document.getElementById('app') as HTMLDivElement
// window.addEventListener

interface Window {
  age: number
}
window.age = 23
console.log(window.age)
```

> Type 与 Interface 的区别就是 Type 不允许重复定义

```ts
// 报错
// type IBar = {
//   name: string
// }
// type IBar = {
//   age: number
// }
```

#### 7.字面量赋值

> 因为 TypeScript 在字面量直接赋值的过程中，为了进行类型推导会进行严格的类型限制。
>
> - 如果我们是将一个变量标识符 赋值给其他的变量时，会进行 `freshness` 擦除操作

```ts
interface IPerson {
  name: string
  age: number
  height: number
}

const p: IPerson = {
  name: "zql",
  age: 23,
  height: 1.8,
  // address: '长葛市' // 报错
}

const info = {
  name: "zql",
  age: 23,
  height: 1.8,
  address: "长葛市",
}

// freshness 擦除
const p2: IPerson = info // 不报错
console.log(info) // { name: 'zql', age: 23, height: 1.8, address: '长葛市' }
console.log(p2) // { name: 'zql', age: 23, height: 1.8, address: '长葛市' }

// 为什么会这样
// 如果定义对象的时候被接口限制的话，会进行类型推导，那么多了一个的话，与之前相同名字的 IPerson 接口规定的类型就会冲突，但是
// 如果我们是将一个变量标识符赋值给其他的变量时，会进行 `freshness` 擦除操作
```

> 这样的话，那么当我们在其他地方使用对象的时候，不用删除多余的对象属性也可以使用，因为默认只会使用规定好的三个属性
>
> 多余属性擦除

```ts
//这样的话，那么当我们在其他地方使用对象的时候，不用删除多余的对象属性也可以使用，因为默认只会使用规定好的三个属性
function printInfo(person: IPerson) {
  console.log(person.name) // 可以获取
  console.log(person.age) // 可以获取
  console.log(person.height) //可以获取
  // 多余属性擦除
  // console.log(person.address); // Error: 类型“IPerson”上不存在属性“address”
}
```

## 九、TypeScript 枚举类型

> 枚举类型是为数不多的 TypeScript 特性有的特性之一：
>
> - 枚举其实就是将一组可能出现的值，一个个列举出来，定义在一个类型中，这个类型就是枚举类型；
> - 枚举允许开发者定义一组命名常量，常量可以是数字、字符串类型；

```ts
// 联合类型实现
// type Direction = "Left" | "Right" | "Top" | "Bottom";

// 枚举类型实现
// enum 是用来定义枚举类型的
enum Direction {
  LEFT,
  RIGHT,
  TOP,
  BOTTOM,
}

function turnDirection(direction: Direction) {
  switch (direction) {
    case Direction.LEFT:
      console.log("改变角色的方向向左")
      break
    case Direction.RIGHT:
      console.log("改变角色的方向向右")
      break
    case Direction.TOP:
      console.log("改变角色的方向向上")
      break
    case Direction.BOTTOM:
      console.log("改变角色的方向向下")
      break
    default:
      const foo: never = direction
      break
  }
}
turnDirection(Direction.LEFT)
turnDirection(Direction.RIGHT)
turnDirection(Direction.TOP)
turnDirection(Direction.BOTTOM)
```

#### 枚举类型的值

> 枚举类型默认是有值的，比如上面的枚举，默认值是这样的：
>
> 当然，我们也可以给枚举其他值：
>
> - 这个时候会从 100 进行递增；
>
> 我们也可以给他们赋值其他的类型：

```ts
// 联合类型实现
// type Direction = "Left" | "Right" | "Top" | "Bottom";

// 枚举类型实现
// enum 是用来定义枚举类型的
enum Direction {
  // 默认值是 0 1 2 3
  // LEFT = 1
  LEFT,
  RIGHT,
  TOP,
  BOTTOM,
}

function turnDirection(direction: Direction) {
  switch (direction) {
    case Direction.LEFT:
      console.log("改变角色的方向向左")
      break
    case Direction.RIGHT:
      console.log("改变角色的方向向右")
      break
    case Direction.TOP:
      console.log("改变角色的方向向上")
      break
    case Direction.BOTTOM:
      console.log("改变角色的方向向下")
      break
    default:
      // never 类型可以保证上面的四个都进行了判断
      const foo: never = direction
      break
  }
}
turnDirection(Direction.LEFT)
turnDirection(Direction.RIGHT)
turnDirection(Direction.TOP)
turnDirection(Direction.BOTTOM)
```

#### 枚举类型的值

> 枚举类型默认是有值的，比如上面的枚举，默认值是这样的：
>
> 当然，我们也可以给枚举其他值：
>
> - 这个时候会从 100 进行递增；
>
> 我们也可以给他们赋值其他的类型：

```ts'
// enum Direction {
//   LEFT = 100,
//   RIGHT, //101
//   TOP, // 102
//   BOTTOM // 103
// }
enum Direction {
  LEFT = "LEFT",
  RIGHT= "RIGHT",
  TOP= "TOP",
  BOTTOM= "BOTTOM"
}

function turnDirection(direction: Direction) {
  switch (direction) {
    case Direction.LEFT:
      console.log('改变角色的方向向左')
      break
    case Direction.RIGHT:
      console.log('改变角色的方向向右')
      break
    case Direction.TOP:
      console.log('改变角色的方向向上')
      break
    case Direction.BOTTOM:
      console.log('改变角色的方向向下')
      break
    default:
      const foo: never = direction
      break
  }
}

turnDirection(Direction.LEFT)
turnDirection(Direction.RIGHT)
turnDirection(Direction.TOP)
turnDirection(Direction.BOTTOM)
```

## 十、泛型(重要)

#### 1.认识泛型

> 软件工程的主要目的是构建不仅仅明确和一致的 API，还要让你的代码具有很强的可重用性：
>
> - 比如我们可以通过函数来封装一些 API，通过传入不同的函数参数，让函数帮助我们完成不同的操作；
> - 但是对于参数的类型是否也可以参数化呢？
>
> 什么是类型的参数化？
>
> - 我们来提一个需求：封装一个函数，传入一个参数，并且返回这个参数；
>
> 如果我们是 TypeScript 的思维方式，要考虑这个参数和返回值的类型需要一致：
>
> ```ts
> function foo(arg: number): number {
>   return arg
> }
> ```
>
> 上面的代码虽然实现了，但是不适用于其他类型，比如 string、boolean、Person 等类型
>
> ```ts
> function foo(arg: any): any {
>   return arg
> }
> ```

```ts
function sum(num1: number, num2: number) {
  return num1 + num2
}

// 为了让函数具备很强的通用性，我们就需要写很多联合类型
// { length: number }：对象类型，需要有 length 属性
type sumType = number | string | any[] | { length: number }
function sum1(num1: sumType, num2: sumType) {
  // return num1 + num2;
}

// 但是这样写出来的代码就非常的冗余
// 那么有没有一种办法，将参数和参数的类型都由外界决定呢？
```

#### 泛型实现类型参数化

> 虽然 any 是可以的，但是定义为 any 的时候，我们其实已经丢失了类型信息：
>
> - 比如我们传入的是一个 number，那么我们希望返回的可不是 any 类型，而是 number 类型；
> - 所以，我们需要在函数中可以捕获到参数的类型是 number，并且同时使用它来作为返回值的类型；
>
> 我们需要在这里使用一种特性的变量 - 类型变量（type variable），它作用于类型，而不是值：
>
> 这里我们可以使用两种方式来调用它：
>
> - 方式一：通过 <类型> 的方式将类型传递给函数；
> - 方式二：通过类型推到，自动推到出我们传入变量的类型：
> - 在这里会推导出它们是 字面量类型的，因为字面量类型对于我们的函数也是适用的

```ts
// 类型的参数化

// 在定义函数时，不决定参数的类型
// 而是让调用者以参数的形式告知，我这里函数的餐宿应该是什么类型
function sum2<Type>(num: Type): Type {
  return num
}

// 调用方式一：明确传入类型
sum2<number>(20)
sum2<{ name: string }>({ name: "zql" })
sum2<any[]>(["abc"])

// 调用方式二：类型推导
sum2("abc") // 推导出来的就是字面量类型 function sum2<"abc">(num: "abc"): "abc"
```

#### 泛型接收多个类型参数

```typescript
function foo<T, E, O>(arg1: T, arg2: E, arg3: O) {}
foo<number, string, boolean>(10, "abc", true)
```

> 名称是自定义的，随意
>
> T：Type 的缩写，类型
>
> K、V：key 和 value 的缩写，键值对
>
> E：Element 的缩写，元素
>
> O：Object 的缩写，对象

```ts
// T 是 Type 的缩写
function foo<T>(arg1: T, arg2: T) {}

// 当两个参数类型不一样可以传入多个参数
function foo1<T, E>(arg1: T, arg2: E) {}
foo1<number, string>(10, "zql")

function foo1<T, E, O>(arg1: T, arg2: E, ...args: O[]) {}
```

#### 泛型接口

> 在定义接口的时候我们也可以使用泛型：

```ts
// 泛型接口的默认类型
interface IPerson<T1 = string, T2 = number> {
  name: T1
  age: T2
}

// 泛型接口，泛型接口的参数类型也可以在使用的时候被传入
const p: IPerson<string, number> = {
  name: "zql",
  age: 23,
}

const p1: IPerson = {
  name: "zql",
  age: 23,
}
```

#### 泛型类

> 我们也可以编写一个类的时候使用泛型：

```ts
class Point<T> {
  x: T
  y: T
  z: T
  constructor(x: T, y: T, z: T) {
    this.x = x
    this.y = y
    this.z = z
  }
}

const p1 = new Point("1.33.2", "2.22.3", "4.22.1")
const p2 = new Point<string>("1.33.2", "2.22.3", "4.22.1")
const p3: Point<string> = new Point("1.33.2", "2.22.3", "4.22.1")

const names1: string[] = ["abc", "cba", "nba"]
const names2: Array<string> = ["abc", "cba", "nba"] // 不推荐（react jsx <>）

export {}
```

#### 泛型的类型约束

> 有时候我们希望传入的类型有某些共性，但是这些共性可能不是在同一种类型中：
>
> - 比如 string 和 array 都是有 length 的，或者某些对象也是会有 length 属性的；
> - 那么只要是拥有 length 的属性都可以作为我们的参数类型，那么应该如何操作呢？

```ts
// function getLength(arg:string|any[]) {
//   return arg.length
// }

interface ILength {
  length: number
}

// 通过 extends 对类型进行约束，来限制这个 T
function getLength<T extends ILength>(arg: T) {
  return arg.length
}

// getLength(123) // 报错,因为我们传入的 123 并不具备 length 属性
getLength("abc") // 字符串是有 length 属性的
getLength(["abc", "cba"]) // 数组也是有 length 属性的
getLength({ length: 100 }) // 对象也是有 length 属性的
```

## 十一、TypeScript 其他内容补充

#### 模块化开发

> TypeScript 支持两种方式来控制我们的作用域：
>
> - 模块化：每个文件可以是一个独立的模块，支持 `ES Module`，也支持 `CommonJS`；
> - 命名空间：通过 `namespace` 来声明一个命名空间

12_TypeScript 其他内容补充\src\utils

```ts
export function sum(num1: number, num2: number) {
  return num1 + num2
}

export function sub(num1: number, num2: number) {
  return num1 - num2
}
```

12_TypeScript 其他内容补充\src\main.ts

```ts
import { add, sub } from "./utils/math"
console.log(add(20, 30)) // 50
console.log(sub(20, 30)) // -10
```

#### 命名空间 namespace

> - 命名空间在 TypeScript 早期时，称之为内部模块，**主要目的是将一个模块内部再进行作用域的划分，防止一些命名冲突的问题。**

12_TypeScript 其他内容补充\src\utils\format.ts

```ts
// 正常情况下解决命名冲突问题
// export function timeFormat(time: string) {
//   return "2022-02-22";
// }
// export function format(price: number) {
//   return "99.99";
// }

export namespace time {
  export function format(time: string) {
    return "2222-02-22"
  }
  export function foo() {}
  export let name: string = "abc"
}
export namespace price {
  export function format(price: number) {
    return "99.99"
  }
}

// 使用，通过   命名空间.format 拿到函数
time.format
time.foo
time.name
price.format
```

12_TypeScript 其他内容补充\src\main.ts

```ts
import { sum, sub } from "./utils/math"
import { time, price } from "./utils/format"
console.log(sum(20, 30))
console.log(sub(20, 30))
console.log(time.format("1111"))
console.log(price.format(123))
```

#### 类型的查找

> 之前我们所有的 typescript 中的类型，几乎都是我们自己编写的，但是我们也有用到一些其他的类型

```ts
const imageEl = document.getElementById("image") as HTMLImageElement
```

> 大家是否会奇怪，我们的 HTMLImageElement 类型来自哪里呢？甚至是 document 为什么可以有 getElementById 的方法呢？
>
> - 其实这里就涉及到 typescript 对类型的管理和查找规则了。
>
> 另外的一种 typescript 文件：.d.ts 文件
>
> - 我们之前编写的 typescript 文件都是 .ts 文件，这些文件最终会输出 .js 文件，也是我们通常编写代码的地方；
> - 还有另外一种文件 .d.ts 文件，它是用来做类型的声明(declare)。 它仅仅用来做类型检测，告知 typescript 我们有哪些类型；
>
> 那么 typescript 会在哪里查找我们的类型声明呢？
>
> - 内置类型声明；
> - 外部定义类型声明；
> - 自己定义类型声明；

#### 内置类型声明

> 内置类型声明是 typescript 自带的、帮助我们内置了 JavaScript 运行时的一些标准化 API 的声明文件；
>
> - 包括比如 Math、Date 等内置类型，也包括 DOM API，比如 Window、Document 等；
>
> 内置类型声明通常在我们安装 typescript 的环境中会带有的；
>
> - https://github.com/microsoft/TypeScript/tree/main/lib

```ts
import { sum, sub } from "./utils/math"
import { time, price } from "./utils/format"

// 为什么这里的 axios 就不报错，因为在第三方库中就有对第三方库的类型声明
// 12_TypeScript其他内容补充\node_modules\axios
import axios from "axios"

// 但是 lodash 却报错呢？因为没有对 lodash 第三方库的类型声明
// 12_TypeScript其他内容补充\node_modules\lodash 里面全是 JS 代码不识别
// import lodash from "lodash";

console.log(sum(20, 30))
console.log(sub(20, 30))
console.log(time.format("1111"))
console.log(price.format(123))

axios.get("http://123.207.32.32:8000/home/multidata").then((res) => {
  console.log(res)
})
```

#### 外部定义类型声明和自定义声明

> 外部类型声明通常是我们使用一些库（比如第三方库）时，需要的一些类型声明。
>
> 这些库通常有两种类型声明方式：
>
> - 方式一：在自己库中进行类型声明（编写.d.ts 文件），比如 axios
> - 方式二：通过社区的一个公有库 DefinitelyTyped 存放类型声明文件
>   - 该库的 GitHub 地址：https://github.com/DefinitelyTyped/DefinitelyTyped/
>   - 该库查找声明安装方式的地址：https://www.typescriptlang.org/dt/search?search=
>   - 比如我们安装 react 的类型声明： `npm i @types/react --save-dev`
>
> 什么情况下需要自己来定义声明文件呢？
>
> - 情况一：我们使用的第三方库是一个纯的 JavaScript 库，没有对应的声明文件；比如 lodash
> - 情况二：我们给自己的代码中声明一些类型，方便在其他地方直接进行使用；

#### 声明变量-函数-类

```ts
// 声明变量/函数/类
declare let qlName: string
declare let qlAge: number
declare let qlHeight: number
declare function qlFoo(): viod
declare class Person {
  name: string
  age: number
  constructor(name: string, age: number) {
    this.name = name
    this.age = age
  }
}
```

#### 声明模块

```ts
declare module "lodash" {
  export function join(arr: any[]): void
}
```

#### declare 文件

> 在某些情况下，我们也可以声明文件：
>
> - 比如在开发 vue 的过程中，默认是不识别我们的.vue 文件的，那么我们就需要对其进行文件的声明；
> - 比如在开发中我们使用了 jpg 这类图片文件，默认 typescript 也是不支持的，也需要对其进行声明；

```ts
declare module '*.jpg'
declare module '*.jpeg'
declare module '*.png'
declare module '*.svg'
declare module '*.gif'
declare module '*.vue' {
  import { DefineComponent } from 'vue'
  const component: DefineComponent
  export component
}
```

#### declare 命名空间

> 比如我们在 index.html 中直接引入了 jQuery：
>
> - CDN 地址： https://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.js

我们可以进行命名空间的声明：

```ts
declare namespace $ {
  export function ajax(setting: any): any
}
```

在 main.ts 中就可以使用了：

```ts
$.ajax({
  url: "hrrp://123.207.32.32:8000/home/multidata",
  success(res: any) {
    console.log(res)
  },
})
```

#### tsconfig.json 文件

> tsconfig.json 是用于配置 TypeScript 编译时的配置选项：
>
> - https://www.typescriptlang.org/tsconfig
