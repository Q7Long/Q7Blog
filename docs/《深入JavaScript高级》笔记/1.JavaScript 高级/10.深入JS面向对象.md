---
title: 深入JS面向对象
date: 2022-12-26 21:16:31
permalink: /pages/38ddc2/
categories:
  - 《深入JavaScript高级》笔记
tags:
  -
author:
  name: Q7Long
  link: https://github.com/Q7Long
---

# 10 深入 JS 面向对象

## 面向对象是现实的抽象方式

## JavaScript 的面向对象

JavaScript 其实支持多种编程范式，包含**函数式编程和面向对象编程**

JavaScript 的对象被设计成一组属性的无序集合，像是一个哈希表，有`**key和value组成**`

**key 是一个标识符名称，value 可以是任意类型，也可以是其他对象或者函数类型**

**如果值是一个函数，**那么我们可以称之为是**对象的方法**

### 创建对象的方式

#### 创建方式一: 通过 new Object() 创建

1. 下面这种相当于是调用了 Object() 函数，执行这个函数之后就会创建一个对象

![img](http://www.zhangqilong.cn/img/qlBlog_images/%E6%B7%B1%E5%85%A5JavaScript%E9%AB%98%E7%BA%A7/10.%E6%B7%B1%E5%85%A5JS%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/image1.png)

#### 创建方式二: 字面量形式

![img](http://www.zhangqilong.cn/img/qlBlog_images/%E6%B7%B1%E5%85%A5JavaScript%E9%AB%98%E7%BA%A7/10.%E6%B7%B1%E5%85%A5JS%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/image2.png)

### 对对象属性的操作

#### 获取属性值

![img](http://www.zhangqilong.cn/img/qlBlog_images/%E6%B7%B1%E5%85%A5JavaScript%E9%AB%98%E7%BA%A7/10.%E6%B7%B1%E5%85%A5JS%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/image3.png)

#### 删除属性值

![img](http://www.zhangqilong.cn/img/qlBlog_images/%E6%B7%B1%E5%85%A5JavaScript%E9%AB%98%E7%BA%A7/10.%E6%B7%B1%E5%85%A5JS%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/image4.png)

#### 特殊需求，对属性进行精准控制

需求: 对属性进行操作时，进行一些限制

限制: 不允许某一属性被赋值/不允许某个属性被删除/不允许某些属性在遍历时被遍历出来

// 遍历属性

```
for(var k in obj){
console.log(k)`                           `**// name age study**(需要注意的是，这里就是study)
}
```

##### 对属性操作的控制 Object.defineProperty()

**返回值:被传递给的对象** **如果不返回也会对原对象进行修改** 所以这个函数不是纯函数

1. Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象
2. Object.defineProperty() 三个参数

```
**对象名，属性名，要定义或修改的属性描述符（属性描述符是一个****对象****）**
```

1. 举例

1. 1. 当对象里面有需要修改的属性时候

 `**Object.defineProperty(obj,"name",属性描述符)**`

注意属性值需要带引号

1. 1. 当对象里面没有需要修改的属性时

没有的属性值会被创建出来

```
**Object.defineProperty(obj,"sex",属性描述符)**
```

![img](http://www.zhangqilong.cn/img/qlBlog_images/%E6%B7%B1%E5%85%A5JavaScript%E9%AB%98%E7%BA%A7/10.%E6%B7%B1%E5%85%A5JS%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/image5.png)

#### defineProperty 方法 默认值 false

![img](http://www.zhangqilong.cn/img/qlBlog_images/%E6%B7%B1%E5%85%A5JavaScript%E9%AB%98%E7%BA%A7/10.%E6%B7%B1%E5%85%A5JS%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/image6.png)

##### 数据属性描述符

![img](http://www.zhangqilong.cn/img/qlBlog_images/%E6%B7%B1%E5%85%A5JavaScript%E9%AB%98%E7%BA%A7/10.%E6%B7%B1%E5%85%A5JS%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/image7.png)

###### configurable：false 不可修改、删除 默认值 false

1. 没有使用的时候

![img](http://www.zhangqilong.cn/img/qlBlog_images/%E6%B7%B1%E5%85%A5JavaScript%E9%AB%98%E7%BA%A7/10.%E6%B7%B1%E5%85%A5JS%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/image8.png)

![img](http://www.zhangqilong.cn/img/qlBlog_images/%E6%B7%B1%E5%85%A5JavaScript%E9%AB%98%E7%BA%A7/10.%E6%B7%B1%E5%85%A5JS%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/image9.png)

###### enumerable：false 不可枚举的 默认值 false

![img](http://www.zhangqilong.cn/img/qlBlog_images/%E6%B7%B1%E5%85%A5JavaScript%E9%AB%98%E7%BA%A7/10.%E6%B7%B1%E5%85%A5JS%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/image10.png)

###### writable：false 不可修改的

![img](http://www.zhangqilong.cn/img/qlBlog_images/%E6%B7%B1%E5%85%A5JavaScript%E9%AB%98%E7%BA%A7/10.%E6%B7%B1%E5%85%A5JS%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/image11.png)

###### value 默认是 undefined

![img](http://www.zhangqilong.cn/img/qlBlog_images/%E6%B7%B1%E5%85%A5JavaScript%E9%AB%98%E7%BA%A7/10.%E6%B7%B1%E5%85%A5JS%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/image12.png)

##### 存取属性描述符

![img](http://www.zhangqilong.cn/img/qlBlog_images/%E6%B7%B1%E5%85%A5JavaScript%E9%AB%98%E7%BA%A7/10.%E6%B7%B1%E5%85%A5JS%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/image13.png)

###### **⭐**get set 存取属性描述符

![img](http://www.zhangqilong.cn/img/qlBlog_images/%E6%B7%B1%E5%85%A5JavaScript%E9%AB%98%E7%BA%A7/10.%E6%B7%B1%E5%85%A5JS%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/image14.png)

---

一般情况下什么时候会用到 get set？

1. 现在 obj 里面有个属性，不希望这个属性随便被暴露出去 `_address 下划线表示私有的`

隐藏某一私有属性，不希望直接被外界使用和赋值

![img](http://www.zhangqilong.cn/img/qlBlog_images/%E6%B7%B1%E5%85%A5JavaScript%E9%AB%98%E7%BA%A7/10.%E6%B7%B1%E5%85%A5JS%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/image15.png)

1. 如果我们希望截获某一属性它访问和设置值的过程时，它会使用存储属性描述符

![img](http://www.zhangqilong.cn/img/qlBlog_images/%E6%B7%B1%E5%85%A5JavaScript%E9%AB%98%E7%BA%A7/10.%E6%B7%B1%E5%85%A5JS%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/image16.png)

###### get set 有什么用？ ----> vue2 响应式的原理

通过 get,当某个地方对这个属性值有依赖的时候，都会收集对应的依赖，当有一天需要修改属性值的时候，就从这个依赖里面拿到该执行的那些方法，全部执行一遍，当数据发生改变的时候，就会去更新该更新的那些东西

![img](http://www.zhangqilong.cn/img/qlBlog_images/%E6%B7%B1%E5%85%A5JavaScript%E9%AB%98%E7%BA%A7/10.%E6%B7%B1%E5%85%A5JS%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/image17.png)

### 定义多个属性描述符 Object.defineProperties()

私有属性(js 里面没有严格意义的私有属性)，但是有约定俗成的概念 \_age:18 这个 \_age 就是指私有属性

![img](http://www.zhangqilong.cn/img/qlBlog_images/%E6%B7%B1%E5%85%A5JavaScript%E9%AB%98%E7%BA%A7/10.%E6%B7%B1%E5%85%A5JS%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/image18.png)

#### 当可配置和可枚举都为 true 的时候，可以换一种写法

```
configurable:true,``enumerable:true,
```

![img](http://www.zhangqilong.cn/img/qlBlog_images/%E6%B7%B1%E5%85%A5JavaScript%E9%AB%98%E7%BA%A7/10.%E6%B7%B1%E5%85%A5JS%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/image19.png)

#### 获取某一特性属性的属性描述符

```
console.log(Object.getOwnPropertyDescriptor(obj,"name"))
```

#### 获取对象的所有属性描述符

```
console.log(Object.getOwnPropertyDescriptors(obj))
```

#### Object 的方法对对象限制(不常用)

![img](http://www.zhangqilong.cn/img/qlBlog_images/%E6%B7%B1%E5%85%A5JavaScript%E9%AB%98%E7%BA%A7/10.%E6%B7%B1%E5%85%A5JS%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/image20.png)

1. 禁止对象继续添加新的属性

```
Object.preventExtensions(obj)
```

![img](http://www.zhangqilong.cn/img/qlBlog_images/%E6%B7%B1%E5%85%A5JavaScript%E9%AB%98%E7%BA%A7/10.%E6%B7%B1%E5%85%A5JS%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/image21.png)

1. 禁止对象配置或删除里面的属性

![img](http://www.zhangqilong.cn/img/qlBlog_images/%E6%B7%B1%E5%85%A5JavaScript%E9%AB%98%E7%BA%A7/10.%E6%B7%B1%E5%85%A5JS%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/image22.png)

![img](http://www.zhangqilong.cn/img/qlBlog_images/%E6%B7%B1%E5%85%A5JavaScript%E9%AB%98%E7%BA%A7/10.%E6%B7%B1%E5%85%A5JS%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/image23.png)

1. 让属性不可以修改:`writable:false`

![img](http://www.zhangqilong.cn/img/qlBlog_images/%E6%B7%B1%E5%85%A5JavaScript%E9%AB%98%E7%BA%A7/10.%E6%B7%B1%E5%85%A5JS%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/image24.png)

## 创建多个对象的方案

如果我们现在希望创建一系列的对象:比如 Person 对象

包含张三，李四，王五，李磊等等，他们的信息各不相同

那么采用什么样的方式创建比较好呢？

```
name:'张三',age:18  ||  name:'李四',age:23  || name:'王五',age:18
```

### JS 创建对象的方案

#### 创建对象的方案-字面量

![img](http://www.zhangqilong.cn/img/qlBlog_images/%E6%B7%B1%E5%85%A5JavaScript%E9%AB%98%E7%BA%A7/10.%E6%B7%B1%E5%85%A5JS%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/image25.png)

![img](http://www.zhangqilong.cn/img/qlBlog_images/%E6%B7%B1%E5%85%A5JavaScript%E9%AB%98%E7%BA%A7/10.%E6%B7%B1%E5%85%A5JS%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/image26.png)

但是通过对象字面量的方式创建对象的方式，太过于繁琐，如果需要创建多个的时候，就非常的麻烦

#### 创建对象的方案-工厂模式

1. 我们可以想到的一种创建对象的方式:工厂模式

 工厂模式其实是一种常见的设计模式

 通常我们会有一个工厂方法，通过该工厂方法我们可以产生想要的对象

![img](http://www.zhangqilong.cn/img/qlBlog_images/%E6%B7%B1%E5%85%A5JavaScript%E9%AB%98%E7%BA%A7/10.%E6%B7%B1%E5%85%A5JS%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/image27.png)

##### 工厂模式的缺点

![img](http://www.zhangqilong.cn/img/qlBlog_images/%E6%B7%B1%E5%85%A5JavaScript%E9%AB%98%E7%BA%A7/10.%E6%B7%B1%E5%85%A5JS%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/image28.png)

通过这种办法进行打印的时候，只能看到结果是 Object 类型 但是不能准确到具体的类型，比如这里是 createPerson()的函数，如果这里又有一个 createDog()函数，那么打印出来的结果也是 Object 类型，但是却没有办法具体到具体的类型，分类不够具体

比如说在 java 中 创建对象的方式是 Person p = new Person() 这里就可以直接知道这个对象具体的类型，但是工厂打印出来的是对象字面量，但是却没有办法具体到什么类型

工厂模式可以解决代码重复问题，但是不能解决类型问题

#### **⭐⭐⭐ 构造函数**

1. 工厂方法创建对象有一个比较大的问题:我们在打印对象时，对象的类型都是 Object 类型，并不能具体到是什么类型，在 Java 里面创建对象的方法是

Person p = new Person(); 可以具体到某一具体的类型

1. 但是从某些角度来说，这些对象应该有一个他们共同的类型
2. 构造函数的方式

##### 我们先理解什么是构造函数？

构造函数也称之为构造器`(constructor)`,通常是我们在**创建对象时会调用的函数**

在其他面向对象的编程语言里面，构造函数是存在于类中的一个方法，称之为构造方法

但是 JavaScript 中的构造函数有点不太一样

构造函数也是一个普通的函数，从表现形式来说，和千千万万个普通的函数没有任何区别

那么如果这么一个**普通的函数被使用 new 操作符来调用了，**那么这个函数就**称之为是一个构造函数**

---

1. 如果函数通过 foo() 这种方式调用的时候，foo 就是一个普通的函数

```
function foo(){
```

console.log("foo~")

```
}
foo()`                             `**// foo~**
```

1. 换一种方式来调用 foo 函数，通过 new 关键字去调用一个函数，那么这个函数就是一个构造函数了

```
new foo();`                  `**// foo~**
```

甚至用 new 之后，可以直接 new foo 调用,如果函数里面不需要参数,那么可以直接通过下面的方式进行调用函数

```
new foo `                      `**// foo~**
```

但是为什么要加 () 呢，因为一般情况下，这里面是需要传入参数的

```
new foo("aaaa","vvvv","cccc")
```

##### new 操作符调用的作用

1. 通过 new 调用到底会执行什么操作?

![img](http://www.zhangqilong.cn/img/qlBlog_images/%E6%B7%B1%E5%85%A5JavaScript%E9%AB%98%E7%BA%A7/10.%E6%B7%B1%E5%85%A5JS%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/image29.png)

与工厂模式创建出来的对象的区别就是这里可以显示对象的类型 foo

---

##### 使用构造函数传入参数

![img](http://www.zhangqilong.cn/img/qlBlog_images/%E6%B7%B1%E5%85%A5JavaScript%E9%AB%98%E7%BA%A7/10.%E6%B7%B1%E5%85%A5JS%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/image30.png)

区别就是这里可以显示出来对象的类型，比如这里就是 person

![img](http://www.zhangqilong.cn/img/qlBlog_images/%E6%B7%B1%E5%85%A5JavaScript%E9%AB%98%E7%BA%A7/10.%E6%B7%B1%E5%85%A5JS%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/image31.png)

但是使用构造函数，从表形式上来看，无法区分是否以后把这个作为构造函数使用，所以这里有个约定俗成的标识就是

构造函数的规范 : 构造函数函数名的首字母大写用于区分(但是不是必须的)

![img](http://www.zhangqilong.cn/img/qlBlog_images/%E6%B7%B1%E5%85%A5JavaScript%E9%AB%98%E7%BA%A7/10.%E6%B7%B1%E5%85%A5JS%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/image32.png)

##### 构造函数的缺点

1. 每次执行函数内部都会创建一个新的 bar() 函数指向不同的内存地址

![img](http://www.zhangqilong.cn/img/qlBlog_images/%E6%B7%B1%E5%85%A5JavaScript%E9%AB%98%E7%BA%A7/10.%E6%B7%B1%E5%85%A5JS%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/image33.png)

这里是因为在创建的时候，每次都会创建并且返回出一个**新的对象 bar()** 存放在不同的地址，所以这里生成的两个是不一样的内存地址

1. 函数执行，如果没有用一个值进行接收的话，那么会直接被内存销毁掉

![img](http://www.zhangqilong.cn/img/qlBlog_images/%E6%B7%B1%E5%85%A5JavaScript%E9%AB%98%E7%BA%A7/10.%E6%B7%B1%E5%85%A5JS%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/image34.png)

1. 对象里面的方法在执行的时候，函数都会在堆里面开辟一块新的空间,所以每次创建出来的对象的方法都是一个新的堆空间，p1 的 eating 方法 和 p1 的 runing 方法 和 p2 的 eating 方法 和 p2 的 runing 方法 任意两个都是不一样堆内存地址，代码如下:

![img](http://www.zhangqilong.cn/img/qlBlog_images/%E6%B7%B1%E5%85%A5JavaScript%E9%AB%98%E7%BA%A7/10.%E6%B7%B1%E5%85%A5JS%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/image35.png)

构造函数的缺点，就是如果对象里面如果有函数的时候，每次都会创建一个新的函数放进堆里面，但是每个对象用构造函数生成出来函数都是一样的，如果每次都新创建一个，那么就会浪费堆内存空间

##### 如何优化每次创建都会生成新堆内存的问题？

原型 见下一章节
