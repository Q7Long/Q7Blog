---
title: 闭包内存回收和this的四个绑定规则
date: 2022-12-26 21:07:21
permalink: /pages/94f0df/
categories:
  - 《深入JavaScript高级》笔记
tags:
  -
author:
  name: Q7Long
  link: https://github.com/Q7Long
---

# 05 闭包内存回收和 this 的四个绑定规则

#### js 闭包内存泄漏案例

**在内存中一个整数占据 4 个字节 4byte**
![img](http://www.zhangqilong.cn/img/qlBlog_images/深入JavaScript高级/05.闭包内存回收和this的四个绑定规则/image1.png)

![img](http://www.zhangqilong.cn/img/qlBlog_images/深入JavaScript高级/05.闭包内存回收和this的四个绑定规则/image2.png)
![img](http://www.zhangqilong.cn/img/qlBlog_images/深入JavaScript高级/05.闭包内存回收和this的四个绑定规则/image3.png)

## js 闭包引用的自由变量销毁

![img](http://www.zhangqilong.cn/img/qlBlog_images/深入JavaScript高级/05.闭包内存回收和this的四个绑定规则/image4.png)

![img](http://www.zhangqilong.cn/img/qlBlog_images/深入JavaScript高级/05.闭包内存回收和this的四个绑定规则/image5.png)

**在代码执行过程中，即使 foo 函数还会被 bar 函数对象指向，foo 函数对象里面的属性是不会被销毁的**

**但是由于这边的 arr 和 age 在 bar 里面没有调用，所以 js 引擎 会给不用的 age 或者 arr 销毁 节省内存空间**

![img](http://www.zhangqilong.cn/img/qlBlog_images/深入JavaScript高级/05.闭包内存回收和this的四个绑定规则/image6.png)

## 证明 不用的上层函数 AO 里面的变量会被删除 观察内存中的表现

在代码执行到 bar 函数的时候，会先对代码进行编译，就会发现函数里面有 name 而没有 age 属性 所以在执行代码的时候会把 age 销毁掉

![img](http://www.zhangqilong.cn/img/qlBlog_images/深入JavaScript高级/05.闭包内存回收和this的四个绑定规则/image7.png)
![img](http://www.zhangqilong.cn/img/qlBlog_images/深入JavaScript高级/05.闭包内存回收和this的四个绑定规则/image8.png)

# this

## this 的作用

**其实在 js 中不使用 this 有些问题也是可以解决的**

![img](http://www.zhangqilong.cn/img/qlBlog_images/深入JavaScript高级/05.闭包内存回收和this的四个绑定规则/image9.png)
![img](http://www.zhangqilong.cn/img/qlBlog_images/深入JavaScript高级/05.闭包内存回收和this的四个绑定规则/image10.png)

**但是当对象改名字的时候，\*\***不使用 this\***\*的情况下 里面的属性名 也要跟着改变\*\***(比较麻烦)\*\*

![img](http://www.zhangqilong.cn/img/qlBlog_images/深入JavaScript高级/05.闭包内存回收和this的四个绑定规则/image11.png)

## this 到底指向什么东西？

**普通函数独立函数调用(直接调用)指向的是 window 箭头函数在独立函数调用的时候，会寻找上层作用域**

### this 在全局作用域指向什么？

在大多数情况下 this 都是出现在函数中

在全局作用域下

console.log(this)

**浏览器**下打印出来 : window(globalObject)

**Node**环境打印出来空对象 : {}

![img](http://www.zhangqilong.cn/img/qlBlog_images/深入JavaScript高级/05.闭包内存回收和this的四个绑定规则/image12.png)

#### 从 Node 源码角度来看为什么 在 node 环境下打印 this 是空对象(对上面过程的解析)

![img](http://www.zhangqilong.cn/img/qlBlog_images/深入JavaScript高级/05.闭包内存回收和this的四个绑定规则/image13.png)
![img](http://www.zhangqilong.cn/img/qlBlog_images/深入JavaScript高级/05.闭包内存回收和this的四个绑定规则/image14.png)

![img](http://www.zhangqilong.cn/img/qlBlog_images/深入JavaScript高级/05.闭包内存回收和this的四个绑定规则/image15.png)

### this 在函数作用域指向什么？

this 的指向是在函数执行的时候确定的，在函数定义的时候是确定不了

实际上 this 的最终指向的是那个调用它的对象

![img](http://www.zhangqilong.cn/img/qlBlog_images/深入JavaScript高级/05.闭包内存回收和this的四个绑定规则/image16.png)

### ⭐⭐⭐this 的三种调用方式区别

**⭐⭐this 的指向，跟函数所处的位置无关，只与调用时候的调用方式有关**

**即使函数在定义的时候是在对象内部，但是只要调用的时候是 foo() 直接调用的方式，this 的指向就是 window**

![img](http://www.zhangqilong.cn/img/qlBlog_images/深入JavaScript高级/05.闭包内存回收和this的四个绑定规则/image17.png)
![img](http://www.zhangqilong.cn/img/qlBlog_images/深入JavaScript高级/05.闭包内存回收和this的四个绑定规则/image18.png)

#### this 到底指向什么与其绑定规则是有关系的

![img](http://www.zhangqilong.cn/img/qlBlog_images/深入JavaScript高级/05.闭包内存回收和this的四个绑定规则/image19.png)

#### **⭐**this 绑定规则一 -默认绑定:独立函数调用

**_独立函数调用 foo() 这时候的 this 指向 window_**

**_案例一_**

![img](http://www.zhangqilong.cn/img/qlBlog_images/深入JavaScript高级/05.闭包内存回收和this的四个绑定规则/image20.png)

**_案例二_**

![img](http://www.zhangqilong.cn/img/qlBlog_images/深入JavaScript高级/05.闭包内存回收和this的四个绑定规则/image21.png)
![img](http://www.zhangqilong.cn/img/qlBlog_images/深入JavaScript高级/05.闭包内存回收和this的四个绑定规则/image22.png)

**_案例三_**

![img](http://www.zhangqilong.cn/img/qlBlog_images/深入JavaScript高级/05.闭包内存回收和this的四个绑定规则/image23.png)
![img](http://www.zhangqilong.cn/img/qlBlog_images/深入JavaScript高级/05.闭包内存回收和this的四个绑定规则/image24.png)

**_案例四_**

![img](http://www.zhangqilong.cn/img/qlBlog_images/深入JavaScript高级/05.闭包内存回收和this的四个绑定规则/image25.png)

![img](http://www.zhangqilong.cn/img/qlBlog_images/深入JavaScript高级/05.闭包内存回收和this的四个绑定规则/image26.png)

**_案例五_**

![img](http://www.zhangqilong.cn/img/qlBlog_images/深入JavaScript高级/05.闭包内存回收和this的四个绑定规则/image27.png)
![img](http://www.zhangqilong.cn/img/qlBlog_images/深入JavaScript高级/05.闭包内存回收和this的四个绑定规则/image28.png)

**\*警惕\*\*\*\***：网上错误言论 闭包里面的函数 this 指向的就是 window**\*\***(错误)\*\*\*

**_比如_**

![img](http://www.zhangqilong.cn/img/qlBlog_images/深入JavaScript高级/05.闭包内存回收和this的四个绑定规则/image29.png)

#### **⭐**this 绑定规则二 -隐式绑定

**_上面的 obj.eating() 前面是有调用主题 obj 的 在调用的时候 通过一个对象把这个方法(函数)给调起来的_**

**\*隐式绑定就是通过\*\*\*\***某个对象发起的函数调用 ， 函数需要调用的时候，先给它绑定到某个对象上面去，然后通过对象调用\*\*\*

**_隐式绑定：object.fn()_**

**_object 对象会被 js 引擎绑定到 fn 函数的中 this 里面_**

**_案例一_**

![img](http://www.zhangqilong.cn/img/qlBlog_images/深入JavaScript高级/05.闭包内存回收和this的四个绑定规则/image30.png)

![img](http://www.zhangqilong.cn/img/qlBlog_images/深入JavaScript高级/05.闭包内存回收和this的四个绑定规则/image31.png)

**_案例二_**

**这里的 function 是被 obj 吊起来的，所以里面的 this 会指向 obj**
![img](http://www.zhangqilong.cn/img/qlBlog_images/深入JavaScript高级/05.闭包内存回收和this的四个绑定规则/image32.png)

**_案例三_**

![img](http://www.zhangqilong.cn/img/qlBlog_images/深入JavaScript高级/05.闭包内存回收和this的四个绑定规则/image33.png)
![img](http://www.zhangqilong.cn/img/qlBlog_images/深入JavaScript高级/05.闭包内存回收和this的四个绑定规则/image34.png)

**_案例四_**

![img](http://www.zhangqilong.cn/img/qlBlog_images/深入JavaScript高级/05.闭包内存回收和this的四个绑定规则/image35.png)

![img](http://www.zhangqilong.cn/img/qlBlog_images/深入JavaScript高级/05.闭包内存回收和this的四个绑定规则/image36.png)

**_隐式绑定 总结_**

![img](http://www.zhangqilong.cn/img/qlBlog_images/深入JavaScript高级/05.闭包内存回收和this的四个绑定规则/image37.png)

#### **⭐**this 绑定规则三-显示绑定 (apply,bind,call)

![img](http://www.zhangqilong.cn/img/qlBlog_images/深入JavaScript高级/05.闭包内存回收和this的四个绑定规则/image38.png)

**\*显示绑定：\*\*\*\***call 和 apply 在执行函数时，是可以明确的绑定 this，这个绑定规则称之为**\*\***显示绑定\*\*\*

**_自定义绑定 this 的值_**

![img](http://www.zhangqilong.cn/img/qlBlog_images/深入JavaScript高级/05.闭包内存回收和this的四个绑定规则/image39.png)

**_情况一:_** **_还想让 foo 指向 obj 但是对象内部也不想写属性的情况_**

![img](http://www.zhangqilong.cn/img/qlBlog_images/深入JavaScript高级/05.闭包内存回收和this的四个绑定规则/image40.png)
![img](http://www.zhangqilong.cn/img/qlBlog_images/深入JavaScript高级/05.闭包内存回收和this的四个绑定规则/image41.png)

![img](http://www.zhangqilong.cn/img/qlBlog_images/深入JavaScript高级/05.闭包内存回收和this的四个绑定规则/image42.png)

![img](http://www.zhangqilong.cn/img/qlBlog_images/深入JavaScript高级/05.闭包内存回收和this的四个绑定规则/image43.png)

#### call 和 apply 有什么区别

![img](http://www.zhangqilong.cn/img/qlBlog_images/深入JavaScript高级/05.闭包内存回收和this的四个绑定规则/image44.png)

#### **⭐**this 绑定规则三-显示绑定(bind)

**_bind_**

**\*想要让 this 都绑定为 aaaa，\*\*\*\***如果使用 call 那么需要一个个写，有没有一种简单的办法，\*\*\*

**_调用函数的时候直接就可以绑定 aaa_**

**_bind 会在内存里面开辟一块独立的空间，会在内存里面生成一个新的函数_**

![img](http://www.zhangqilong.cn/img/qlBlog_images/深入JavaScript高级/05.闭包内存回收和this的四个绑定规则/image45.png)

**\*newFoo()函数被明确的绑定 this 对象之后，后面再执行之后，就不需要再一个个的重新绑定，\*\*\*\***需要绑定 this 的时候可以直接调用 bind 函数就可以，而且后面就算是直接调用，this 的值也不会改变\*\*\*

![img](http://www.zhangqilong.cn/img/qlBlog_images/深入JavaScript高级/05.闭包内存回收和this的四个绑定规则/image46.png)

#### ⭐ 显示绑定和默认绑定冲突的时候，优先级更高的是 显示绑定

### ⭐ 绑定规则-new 绑定

**\*new 绑定是创建一块新的内存空间，并不是指向同一个，\*\*\*\***new 一个就会创建出来一个新的内存空间\*\*\*

**_JavaScript 中的函数可以当做一个类的构造函数来使用，也就是使用 new 关键字_**
![img](http://www.zhangqilong.cn/img/qlBlog_images/深入JavaScript高级/05.闭包内存回收和this的四个绑定规则/image47.png)

#### 直接调用 和 new 调用的区别

![img](http://www.zhangqilong.cn/img/qlBlog_images/深入JavaScript高级/05.闭包内存回收和this的四个绑定规则/image48.png)

#### 我们通过一个 new 关键字调用一个函数时(其实就是把这个函数当做一个构造器了)，这个时候 this 是在调用这个构造器时创建出来的对象

**_this = 创建出来的对象_**

**_这个绑定过程就是_** **_new 绑定_**

![img](http://www.zhangqilong.cn/img/qlBlog_images/深入JavaScript高级/05.闭包内存回收和this的四个绑定规则/image49.png)

![img](http://www.zhangqilong.cn/img/qlBlog_images/深入JavaScript高级/05.闭包内存回收和this的四个绑定规则/image50.png)
![img](http://www.zhangqilong.cn/img/qlBlog_images/深入JavaScript高级/05.闭包内存回收和this的四个绑定规则/image51.png)
